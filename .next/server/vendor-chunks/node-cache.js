/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-cache";
exports.ids = ["vendor-chunks/node-cache"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-cache/index.js":
/*!******************************************!*\
  !*** ./node_modules/node-cache/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/ (function() {\n    var exports;\n    exports = module.exports = __webpack_require__(/*! ./lib/node_cache */ \"(rsc)/./node_modules/node-cache/lib/node_cache.js\");\n    exports.version = \"5.1.2\";\n}).call(void 0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7O0FBUUEsR0FDQztJQUNDLElBQUlBO0lBRUpBLFVBQVVDLGlIQUF5QjtJQUVuQ0QsUUFBUUcsT0FBTyxHQUFHO0FBRXBCLEdBQUdDLElBQUksQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuaW1ldHJpeC8uL25vZGVfbW9kdWxlcy9ub2RlLWNhY2hlL2luZGV4LmpzP2M1N2MiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIG5vZGUtY2FjaGUgNS4xLjIgKCAyMDIwLTA3LTAxIClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGVcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1haW50YWluZWQgYnkgICggIClcbiovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBleHBvcnRzO1xuXG4gIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL25vZGVfY2FjaGUnKTtcblxuICBleHBvcnRzLnZlcnNpb24gPSAnNS4xLjInO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwidmVyc2lvbiIsImNhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-cache/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-cache/lib/node_cache.js":
/*!***************************************************!*\
  !*** ./node_modules/node-cache/lib/node_cache.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/ (function() {\n    var EventEmitter, NodeCache, clone, splice = [].splice, boundMethodCheck = function(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new Error(\"Bound instance method accessed before binding\");\n        }\n    }, indexOf = [].indexOf;\n    clone = __webpack_require__(/*! clone */ \"(rsc)/./node_modules/clone/clone.js\");\n    EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n    // generate superclass\n    module.exports = NodeCache = (function() {\n        class NodeCache extends EventEmitter {\n            constructor(options = {}){\n                super();\n                // ## get\n                // get a cached key and change the stats\n                // **Parameters:**\n                // * `key` ( String | Number ): cache key\n                // **Example:**\n                //\tmyCache.get \"myKey\", ( err, val )\n                this.get = this.get.bind(this);\n                // ## mget\n                // get multiple cached keys at once and change the stats\n                // **Parameters:**\n                // * `keys` ( String|Number[] ): an array of keys\n                // **Example:**\n                //\tmyCache.mget [ \"foo\", \"bar\" ]\n                this.mget = this.mget.bind(this);\n                // ## set\n                // set a cached key and change the stats\n                // **Parameters:**\n                // * `key` ( String | Number ): cache key\n                // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n                // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n                // **Example:**\n                //\tmyCache.set \"myKey\", \"my_String Value\"\n                //\tmyCache.set \"myKey\", \"my_String Value\", 10\n                this.set = this.set.bind(this);\n                // ## mset\n                // set multiple keys at once\n                // **Parameters:**\n                // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n                // **Example:**\n                //\tmyCache.mset(\n                //\t\t[\n                //\t\t\t{\n                //\t\t\t\tkey: \"myKey\",\n                //\t\t\t\tval: \"myValue\",\n                //\t\t\t\tttl: [ttl in seconds]\n                //\t\t\t}\n                //\t\t])\n                this.mset = this.mset.bind(this);\n                // ## del\n                // remove keys\n                // **Parameters:**\n                // * `keys` ( String |Â Number | String|Number[] ): cache key to delete or a array of cache keys\n                // **Return**\n                // ( Number ): Number of deleted keys\n                // **Example:**\n                //\tmyCache.del( \"myKey\" )\n                this.del = this.del.bind(this);\n                // ## take\n                // get the cached value and remove the key from the cache.\n                // Equivalent to calling `get(key)` + `del(key)`.\n                // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n                // **Parameters:**\n                // * `key` ( String | Number ): cache key\n                // **Example:**\n                //\tmyCache.take \"myKey\", ( err, val )\n                this.take = this.take.bind(this);\n                // ## ttl\n                // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n                // If `ttl` is not passed the default ttl is used.\n                // If `ttl` < 0 the key will be deleted.\n                // **Parameters:**\n                // * `key` ( String | Number ): cache key to reset the ttl value\n                // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n                // **Return**\n                // ( Boolen ): key found and ttl set\n                // **Example:**\n                //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n                //\tmyCache.ttl( \"myKey\", 1000 )\n                this.ttl = this.ttl.bind(this);\n                // ## getTtl\n                // receive the ttl of a key.\n                // **Parameters:**\n                // * `key` ( String | Number ): cache key to check the ttl value\n                // **Return**\n                // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n                // **Example:**\n                //\tmyCache.getTtl( \"myKey\" )\n                this.getTtl = this.getTtl.bind(this);\n                // ## keys\n                // list all keys within this cache\n                // **Return**\n                // ( Array ): An array of all keys\n                // **Example:**\n                //     _keys = myCache.keys()\n                //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n                this.keys = this.keys.bind(this);\n                // ## has\n                // Check if a key is cached\n                // **Parameters:**\n                // * `key` ( String | Number ): cache key to check the ttl value\n                // **Return**\n                // ( Boolean ): A boolean that indicates if the key is cached\n                // **Example:**\n                //     _exists = myCache.has('myKey')\n                //     # true\n                this.has = this.has.bind(this);\n                // ## getStats\n                // get the stats\n                // **Parameters:**\n                // -\n                // **Return**\n                // ( Object ): Stats data\n                // **Example:**\n                //     myCache.getStats()\n                //     # {\n                //     # hits: 0,\n                //     # misses: 0,\n                //     # keys: 0,\n                //     # ksize: 0,\n                //     # vsize: 0\n                //     # }\n                this.getStats = this.getStats.bind(this);\n                // ## flushAll\n                // flush the whole data and reset the stats\n                // **Example:**\n                //     myCache.flushAll()\n                //     myCache.getStats()\n                //     # {\n                //     # hits: 0,\n                //     # misses: 0,\n                //     # keys: 0,\n                //     # ksize: 0,\n                //     # vsize: 0\n                //     # }\n                this.flushAll = this.flushAll.bind(this);\n                // ## flushStats\n                // flush the stats and reset all counters to 0\n                // **Example:**\n                //     myCache.flushStats()\n                //     myCache.getStats()\n                //     # {\n                //     # hits: 0,\n                //     # misses: 0,\n                //     # keys: 0,\n                //     # ksize: 0,\n                //     # vsize: 0\n                //     # }\n                this.flushStats = this.flushStats.bind(this);\n                // ## close\n                // This will clear the interval timeout which is set on checkperiod option.\n                // **Example:**\n                //     myCache.close()\n                this.close = this.close.bind(this);\n                // ## _checkData\n                // internal housekeeping method.\n                // Check all the cached data and delete the invalid values\n                this._checkData = this._checkData.bind(this);\n                // ## _check\n                // internal method the check the value. If it's not valid any more delete it\n                this._check = this._check.bind(this);\n                // ## _isInvalidKey\n                // internal method to check if the type of a key is either `number` or `string`\n                this._isInvalidKey = this._isInvalidKey.bind(this);\n                // ## _wrap\n                // internal method to wrap a value in an object with some metadata\n                this._wrap = this._wrap.bind(this);\n                // ## _getValLength\n                // internal method to calculate the value length\n                this._getValLength = this._getValLength.bind(this);\n                // ## _error\n                // internal method to handle an error message\n                this._error = this._error.bind(this);\n                // ## _initErrors\n                // internal method to generate error message templates\n                this._initErrors = this._initErrors.bind(this);\n                this.options = options;\n                this._initErrors();\n                // container for cached data\n                this.data = {};\n                // module options\n                this.options = Object.assign({\n                    // convert all elements to string\n                    forceString: false,\n                    // used standard size for calculating value size\n                    objectValueSize: 80,\n                    promiseValueSize: 80,\n                    arrayValueSize: 40,\n                    // standard time to live in seconds. 0 = infinity;\n                    stdTTL: 0,\n                    // time in seconds to check all data and delete expired keys\n                    checkperiod: 600,\n                    // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n                    useClones: true,\n                    // whether values should be deleted automatically at expiration\n                    deleteOnExpire: true,\n                    // enable legacy callbacks\n                    enableLegacyCallbacks: false,\n                    // max amount of keys that are being stored\n                    maxKeys: -1\n                }, this.options);\n                // generate functions with callbacks (legacy)\n                if (this.options.enableLegacyCallbacks) {\n                    console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n                    [\n                        \"get\",\n                        \"mget\",\n                        \"set\",\n                        \"del\",\n                        \"ttl\",\n                        \"getTtl\",\n                        \"keys\",\n                        \"has\"\n                    ].forEach((methodKey)=>{\n                        var oldMethod;\n                        // reference real function\n                        oldMethod = this[methodKey];\n                        this[methodKey] = function(...args) {\n                            var cb, err, ref, res;\n                            ref = args, [...args] = ref, [cb] = splice.call(args, -1);\n                            // return a callback if cb is defined and a function\n                            if (typeof cb === \"function\") {\n                                try {\n                                    res = oldMethod(...args);\n                                    cb(null, res);\n                                } catch (error1) {\n                                    err = error1;\n                                    cb(err);\n                                }\n                            } else {\n                                return oldMethod(...args, cb);\n                            }\n                        };\n                    });\n                }\n                // statistics container\n                this.stats = {\n                    hits: 0,\n                    misses: 0,\n                    keys: 0,\n                    ksize: 0,\n                    vsize: 0\n                };\n                // pre allocate valid keytypes array\n                this.validKeyTypes = [\n                    \"string\",\n                    \"number\"\n                ];\n                // initalize checking period\n                this._checkData();\n                return;\n            }\n            get(key) {\n                var _ret, err;\n                boundMethodCheck(this, NodeCache);\n                // handle invalid key types\n                if ((err = this._isInvalidKey(key)) != null) {\n                    throw err;\n                }\n                // get data and incremet stats\n                if (this.data[key] != null && this._check(key, this.data[key])) {\n                    this.stats.hits++;\n                    _ret = this._unwrap(this.data[key]);\n                    // return data\n                    return _ret;\n                } else {\n                    // if not found return undefined\n                    this.stats.misses++;\n                    return void 0;\n                }\n            }\n            mget(keys) {\n                var _err, err, i, key, len, oRet;\n                boundMethodCheck(this, NodeCache);\n                // convert a string to an array of one key\n                if (!Array.isArray(keys)) {\n                    _err = this._error(\"EKEYSTYPE\");\n                    throw _err;\n                }\n                // define return\n                oRet = {};\n                for(i = 0, len = keys.length; i < len; i++){\n                    key = keys[i];\n                    // handle invalid key types\n                    if ((err = this._isInvalidKey(key)) != null) {\n                        throw err;\n                    }\n                    // get data and increment stats\n                    if (this.data[key] != null && this._check(key, this.data[key])) {\n                        this.stats.hits++;\n                        oRet[key] = this._unwrap(this.data[key]);\n                    } else {\n                        // if not found return a error\n                        this.stats.misses++;\n                    }\n                }\n                // return all found keys\n                return oRet;\n            }\n            set(key, value, ttl) {\n                var _err, err, existent;\n                boundMethodCheck(this, NodeCache);\n                // check if cache is overflowing\n                if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n                    _err = this._error(\"ECACHEFULL\");\n                    throw _err;\n                }\n                // force the data to string\n                if (this.options.forceString && !typeof value === \"string\") {\n                    value = JSON.stringify(value);\n                }\n                // set default ttl if not passed\n                if (ttl == null) {\n                    ttl = this.options.stdTTL;\n                }\n                // handle invalid key types\n                if ((err = this._isInvalidKey(key)) != null) {\n                    throw err;\n                }\n                // internal helper variables\n                existent = false;\n                // remove existing data from stats\n                if (this.data[key]) {\n                    existent = true;\n                    this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n                }\n                // set the value\n                this.data[key] = this._wrap(value, ttl);\n                this.stats.vsize += this._getValLength(value);\n                // only add the keys and key-size if the key is new\n                if (!existent) {\n                    this.stats.ksize += this._getKeyLength(key);\n                    this.stats.keys++;\n                }\n                this.emit(\"set\", key, value);\n                // return true\n                return true;\n            }\n            mset(keyValueSet) {\n                var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n                boundMethodCheck(this, NodeCache);\n                // check if cache is overflowing\n                if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n                    _err = this._error(\"ECACHEFULL\");\n                    throw _err;\n                }\n                // loop over keyValueSet to validate key and ttl\n                for(i = 0, len = keyValueSet.length; i < len; i++){\n                    keyValuePair = keyValueSet[i];\n                    ({ key, val, ttl } = keyValuePair);\n                    // check if there is ttl and it's a number\n                    if (ttl && typeof ttl !== \"number\") {\n                        _err = this._error(\"ETTLTYPE\");\n                        throw _err;\n                    }\n                    // handle invalid key types\n                    if ((err = this._isInvalidKey(key)) != null) {\n                        throw err;\n                    }\n                }\n                for(j = 0, len1 = keyValueSet.length; j < len1; j++){\n                    keyValuePair = keyValueSet[j];\n                    ({ key, val, ttl } = keyValuePair);\n                    this.set(key, val, ttl);\n                }\n                return true;\n            }\n            del(keys) {\n                var delCount, err, i, key, len, oldVal;\n                boundMethodCheck(this, NodeCache);\n                // convert keys to an array of itself\n                if (!Array.isArray(keys)) {\n                    keys = [\n                        keys\n                    ];\n                }\n                delCount = 0;\n                for(i = 0, len = keys.length; i < len; i++){\n                    key = keys[i];\n                    // handle invalid key types\n                    if ((err = this._isInvalidKey(key)) != null) {\n                        throw err;\n                    }\n                    // only delete if existent\n                    if (this.data[key] != null) {\n                        // calc the stats\n                        this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n                        this.stats.ksize -= this._getKeyLength(key);\n                        this.stats.keys--;\n                        delCount++;\n                        // delete the value\n                        oldVal = this.data[key];\n                        delete this.data[key];\n                        // return true\n                        this.emit(\"del\", key, oldVal.v);\n                    }\n                }\n                return delCount;\n            }\n            take(key) {\n                var _ret;\n                boundMethodCheck(this, NodeCache);\n                _ret = this.get(key);\n                if (_ret != null) {\n                    this.del(key);\n                }\n                return _ret;\n            }\n            ttl(key, ttl) {\n                var err;\n                boundMethodCheck(this, NodeCache);\n                ttl || (ttl = this.options.stdTTL);\n                if (!key) {\n                    return false;\n                }\n                // handle invalid key types\n                if ((err = this._isInvalidKey(key)) != null) {\n                    throw err;\n                }\n                // check for existent data and update the ttl value\n                if (this.data[key] != null && this._check(key, this.data[key])) {\n                    // if ttl < 0 delete the key. otherwise reset the value\n                    if (ttl >= 0) {\n                        this.data[key] = this._wrap(this.data[key].v, ttl, false);\n                    } else {\n                        this.del(key);\n                    }\n                    return true;\n                } else {\n                    // return false if key has not been found\n                    return false;\n                }\n            }\n            getTtl(key) {\n                var _ttl, err;\n                boundMethodCheck(this, NodeCache);\n                if (!key) {\n                    return void 0;\n                }\n                // handle invalid key types\n                if ((err = this._isInvalidKey(key)) != null) {\n                    throw err;\n                }\n                // check for existant data and update the ttl value\n                if (this.data[key] != null && this._check(key, this.data[key])) {\n                    _ttl = this.data[key].t;\n                    return _ttl;\n                } else {\n                    // return undefined if key has not been found\n                    return void 0;\n                }\n            }\n            keys() {\n                var _keys;\n                boundMethodCheck(this, NodeCache);\n                _keys = Object.keys(this.data);\n                return _keys;\n            }\n            has(key) {\n                var _exists;\n                boundMethodCheck(this, NodeCache);\n                _exists = this.data[key] != null && this._check(key, this.data[key]);\n                return _exists;\n            }\n            getStats() {\n                boundMethodCheck(this, NodeCache);\n                return this.stats;\n            }\n            flushAll(_startPeriod = true) {\n                boundMethodCheck(this, NodeCache);\n                // parameter just for testing\n                // set data empty\n                this.data = {};\n                // reset stats\n                this.stats = {\n                    hits: 0,\n                    misses: 0,\n                    keys: 0,\n                    ksize: 0,\n                    vsize: 0\n                };\n                // reset check period\n                this._killCheckPeriod();\n                this._checkData(_startPeriod);\n                this.emit(\"flush\");\n            }\n            flushStats() {\n                boundMethodCheck(this, NodeCache);\n                // reset stats\n                this.stats = {\n                    hits: 0,\n                    misses: 0,\n                    keys: 0,\n                    ksize: 0,\n                    vsize: 0\n                };\n                this.emit(\"flush_stats\");\n            }\n            close() {\n                boundMethodCheck(this, NodeCache);\n                this._killCheckPeriod();\n            }\n            _checkData(startPeriod = true) {\n                var key, ref, value;\n                boundMethodCheck(this, NodeCache);\n                ref = this.data;\n                // run the housekeeping method\n                for(key in ref){\n                    value = ref[key];\n                    this._check(key, value);\n                }\n                if (startPeriod && this.options.checkperiod > 0) {\n                    this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n                    if (this.checkTimeout != null && this.checkTimeout.unref != null) {\n                        this.checkTimeout.unref();\n                    }\n                }\n            }\n            // ## _killCheckPeriod\n            // stop the checkdata period. Only needed to abort the script in testing mode.\n            _killCheckPeriod() {\n                if (this.checkTimeout != null) {\n                    return clearTimeout(this.checkTimeout);\n                }\n            }\n            _check(key, data) {\n                var _retval;\n                boundMethodCheck(this, NodeCache);\n                _retval = true;\n                // data is invalid if the ttl is too old and is not 0\n                // console.log data.t < Date.now(), data.t, Date.now()\n                if (data.t !== 0 && data.t < Date.now()) {\n                    if (this.options.deleteOnExpire) {\n                        _retval = false;\n                        this.del(key);\n                    }\n                    this.emit(\"expired\", key, this._unwrap(data));\n                }\n                return _retval;\n            }\n            _isInvalidKey(key) {\n                var ref;\n                boundMethodCheck(this, NodeCache);\n                if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n                    return this._error(\"EKEYTYPE\", {\n                        type: typeof key\n                    });\n                }\n            }\n            _wrap(value, ttl, asClone = true) {\n                var livetime, now, oReturn, ttlMultiplicator;\n                boundMethodCheck(this, NodeCache);\n                if (!this.options.useClones) {\n                    asClone = false;\n                }\n                // define the time to live\n                now = Date.now();\n                livetime = 0;\n                ttlMultiplicator = 1000;\n                // use given ttl\n                if (ttl === 0) {\n                    livetime = 0;\n                } else if (ttl) {\n                    livetime = now + ttl * ttlMultiplicator;\n                } else {\n                    // use standard ttl\n                    if (this.options.stdTTL === 0) {\n                        livetime = this.options.stdTTL;\n                    } else {\n                        livetime = now + this.options.stdTTL * ttlMultiplicator;\n                    }\n                }\n                // return the wrapped value\n                return oReturn = {\n                    t: livetime,\n                    v: asClone ? clone(value) : value\n                };\n            }\n            // ## _unwrap\n            // internal method to extract get the value out of the wrapped value\n            _unwrap(value, asClone = true) {\n                if (!this.options.useClones) {\n                    asClone = false;\n                }\n                if (value.v != null) {\n                    if (asClone) {\n                        return clone(value.v);\n                    } else {\n                        return value.v;\n                    }\n                }\n                return null;\n            }\n            // ## _getKeyLength\n            // internal method the calculate the key length\n            _getKeyLength(key) {\n                return key.toString().length;\n            }\n            _getValLength(value) {\n                boundMethodCheck(this, NodeCache);\n                if (typeof value === \"string\") {\n                    // if the value is a String get the real length\n                    return value.length;\n                } else if (this.options.forceString) {\n                    // force string if it's defined and not passed\n                    return JSON.stringify(value).length;\n                } else if (Array.isArray(value)) {\n                    // if the data is an Array multiply each element with a defined default length\n                    return this.options.arrayValueSize * value.length;\n                } else if (typeof value === \"number\") {\n                    return 8;\n                } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n                    // if the data is a Promise, use defined default\n                    // (can't calculate actual/resolved value size synchronously)\n                    return this.options.promiseValueSize;\n                } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n                    return value.length;\n                } else if (value != null && typeof value === \"object\") {\n                    // if the data is an Object multiply each element with a defined default length\n                    return this.options.objectValueSize * Object.keys(value).length;\n                } else if (typeof value === \"boolean\") {\n                    return 8;\n                } else {\n                    // default fallback\n                    return 0;\n                }\n            }\n            _error(type, data = {}) {\n                var error;\n                boundMethodCheck(this, NodeCache);\n                // generate the error object\n                error = new Error();\n                error.name = type;\n                error.errorcode = type;\n                error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n                error.data = data;\n                // return the error object\n                return error;\n            }\n            _initErrors() {\n                var _errMsg, _errT, ref;\n                boundMethodCheck(this, NodeCache);\n                this.ERRORS = {};\n                ref = this._ERRORS;\n                for(_errT in ref){\n                    _errMsg = ref[_errT];\n                    this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n                }\n            }\n            createErrorMessage(errMsg) {\n                return function(args) {\n                    return errMsg.replace(\"__key\", args.type);\n                };\n            }\n        }\n        ;\n        NodeCache.prototype._ERRORS = {\n            \"ENOTFOUND\": \"Key `__key` not found\",\n            \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n            \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n            \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n            \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n        };\n        return NodeCache;\n    }).call(this);\n}).call(void 0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9saWIvbm9kZV9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7O0FBUUEsR0FDQztJQUNDLElBQUlBLGNBQWNDLFdBQVdDLE9BQzNCQyxTQUFTLEVBQUUsQ0FBQ0EsTUFBTSxFQUNsQkMsbUJBQW1CLFNBQVNDLFFBQVEsRUFBRUMsV0FBVztRQUFJLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7WUFBRSxNQUFNLElBQUlDLE1BQU07UUFBa0Q7SUFBRSxHQUNuS0MsVUFBVSxFQUFFLENBQUNBLE9BQU87SUFFdEJOLFFBQVFPLG1CQUFPQSxDQUFDLGtEQUFPO0lBRXZCVCxlQUFlUywwREFBOEI7SUFFN0Msc0JBQXNCO0lBQ3RCQyxPQUFPQyxPQUFPLEdBQUdWLFlBQVksQ0FBQztRQUM1QixNQUFNQSxrQkFBa0JEO1lBQ3RCWSxZQUFZQyxVQUFVLENBQUMsQ0FBQyxDQUFFO2dCQUN4QixLQUFLO2dCQUNMLFNBQVM7Z0JBRVQsd0NBQXdDO2dCQUV4QyxrQkFBa0I7Z0JBRWxCLHlDQUF5QztnQkFFekMsZUFBZTtnQkFFZixvQ0FBb0M7Z0JBRXBDLElBQUksQ0FBQ0MsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRyxDQUFDQyxJQUFJLENBQUMsSUFBSTtnQkFDN0IsVUFBVTtnQkFFVix3REFBd0Q7Z0JBRXhELGtCQUFrQjtnQkFFbEIsaURBQWlEO2dCQUVqRCxlQUFlO2dCQUVmLGdDQUFnQztnQkFFaEMsSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLENBQUNELElBQUksQ0FBQyxJQUFJO2dCQUMvQixTQUFTO2dCQUVULHdDQUF3QztnQkFFeEMsa0JBQWtCO2dCQUVsQix5Q0FBeUM7Z0JBQ3pDLDJJQUEySTtnQkFDM0ksNkVBQTZFO2dCQUU3RSxlQUFlO2dCQUVmLHlDQUF5QztnQkFFekMsNkNBQTZDO2dCQUU3QyxJQUFJLENBQUNFLEdBQUcsR0FBRyxJQUFJLENBQUNB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LFlBQVk7UUFDZDtRQUVBLE9BQU94SDtJQUVULEdBQUcwRCxJQUFJLENBQUMsSUFBSTtBQUVkLEdBQUdBLElBQUksQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FuaW1ldHJpeC8uL25vZGVfbW9kdWxlcy9ub2RlLWNhY2hlL2xpYi9ub2RlX2NhY2hlLmpzPzc0YTciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIG5vZGUtY2FjaGUgNS4xLjIgKCAyMDIwLTA3LTAxIClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGVcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1haW50YWluZWQgYnkgICggIClcbiovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBFdmVudEVtaXR0ZXIsIE5vZGVDYWNoZSwgY2xvbmUsXG4gICAgc3BsaWNlID0gW10uc3BsaWNlLFxuICAgIGJvdW5kTWV0aG9kQ2hlY2sgPSBmdW5jdGlvbihpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IEVycm9yKCdCb3VuZCBpbnN0YW5jZSBtZXRob2QgYWNjZXNzZWQgYmVmb3JlIGJpbmRpbmcnKTsgfSB9LFxuICAgIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG4gIGNsb25lID0gcmVxdWlyZShcImNsb25lXCIpO1xuXG4gIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuICAvLyBnZW5lcmF0ZSBzdXBlcmNsYXNzXG4gIG1vZHVsZS5leHBvcnRzID0gTm9kZUNhY2hlID0gKGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzIE5vZGVDYWNoZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gIyMgZ2V0XG5cbiAgICAgICAgLy8gZ2V0IGEgY2FjaGVkIGtleSBhbmQgY2hhbmdlIHRoZSBzdGF0c1xuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleWAgKCBTdHJpbmcgfCBOdW1iZXIgKTogY2FjaGUga2V5XG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUuZ2V0IFwibXlLZXlcIiwgKCBlcnIsIHZhbCApXG5cbiAgICAgICAgdGhpcy5nZXQgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBtZ2V0XG5cbiAgICAgICAgLy8gZ2V0IG11bHRpcGxlIGNhY2hlZCBrZXlzIGF0IG9uY2UgYW5kIGNoYW5nZSB0aGUgc3RhdHNcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlzYCAoIFN0cmluZ3xOdW1iZXJbXSApOiBhbiBhcnJheSBvZiBrZXlzXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUubWdldCBbIFwiZm9vXCIsIFwiYmFyXCIgXVxuXG4gICAgICAgIHRoaXMubWdldCA9IHRoaXMubWdldC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBzZXRcblxuICAgICAgICAvLyBzZXQgYSBjYWNoZWQga2V5IGFuZCBjaGFuZ2UgdGhlIHN0YXRzXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXlcbiAgICAgICAgLy8gKiBgdmFsdWVgICggQW55ICk6IEEgZWxlbWVudCB0byBjYWNoZS4gSWYgdGhlIG9wdGlvbiBgb3B0aW9uLmZvcmNlU3RyaW5nYCBpcyBgdHJ1ZWAgdGhlIG1vZHVsZSB0cnlzIHRvIHRyYW5zbGF0ZSBpdCB0byBhIHNlcmlhbGl6ZWQgSlNPTlxuICAgICAgICAvLyAqIGBbIHR0bCBdYCAoIE51bWJlciB8IFN0cmluZyApOiAoIG9wdGlvbmFsICkgVGhlIHRpbWUgdG8gbGl2ZSBpbiBzZWNvbmRzLlxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLnNldCBcIm15S2V5XCIsIFwibXlfU3RyaW5nIFZhbHVlXCJcblxuICAgICAgICAvL1x0bXlDYWNoZS5zZXQgXCJteUtleVwiLCBcIm15X1N0cmluZyBWYWx1ZVwiLCAxMFxuXG4gICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuYmluZCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIC8vICMjIG1zZXRcblxuICAgICAgICAvLyBzZXQgbXVsdGlwbGUga2V5cyBhdCBvbmNlXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5VmFsdWVTZXRgICggT2JqZWN0W10gKTogYW4gYXJyYXkgb2Ygb2JqZWN0IHdoaWNoIGluY2x1ZGVzIGtleSx2YWx1ZSBhbmQgdHRsXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUubXNldChcbiAgICAgICAgLy9cdFx0W1xuICAgICAgICAvL1x0XHRcdHtcbiAgICAgICAgLy9cdFx0XHRcdGtleTogXCJteUtleVwiLFxuICAgICAgICAvL1x0XHRcdFx0dmFsOiBcIm15VmFsdWVcIixcbiAgICAgICAgLy9cdFx0XHRcdHR0bDogW3R0bCBpbiBzZWNvbmRzXVxuICAgICAgICAvL1x0XHRcdH1cbiAgICAgICAgLy9cdFx0XSlcblxuICAgICAgICB0aGlzLm1zZXQgPSB0aGlzLm1zZXQuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgZGVsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGtleXNcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlzYCAoIFN0cmluZyB8wqBOdW1iZXIgfCBTdHJpbmd8TnVtYmVyW10gKTogY2FjaGUga2V5IHRvIGRlbGV0ZSBvciBhIGFycmF5IG9mIGNhY2hlIGtleXNcblxuICAgICAgICAvLyAqKlJldHVybioqXG5cbiAgICAgICAgLy8gKCBOdW1iZXIgKTogTnVtYmVyIG9mIGRlbGV0ZWQga2V5c1xuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLmRlbCggXCJteUtleVwiIClcblxuICAgICAgICB0aGlzLmRlbCA9IHRoaXMuZGVsLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIHRha2VcblxuICAgICAgICAvLyBnZXQgdGhlIGNhY2hlZCB2YWx1ZSBhbmQgcmVtb3ZlIHRoZSBrZXkgZnJvbSB0aGUgY2FjaGUuXG4gICAgICAgIC8vIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgZ2V0KGtleSlgICsgYGRlbChrZXkpYC5cbiAgICAgICAgLy8gVXNlZnVsIGZvciBpbXBsZW1lbnRpbmcgYHNpbmdsZSB1c2VgIG1lY2hhbmlzbSBzdWNoIGFzIE9UUCwgd2hlcmUgb25jZSBhIHZhbHVlIGlzIHJlYWQgaXQgd2lsbCBiZWNvbWUgb2Jzb2xldGUuXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXlcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS50YWtlIFwibXlLZXlcIiwgKCBlcnIsIHZhbCApXG5cbiAgICAgICAgdGhpcy50YWtlID0gdGhpcy50YWtlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIHR0bFxuXG4gICAgICAgIC8vIHJlc2V0IG9yIHJlZGVmaW5lIHRoZSB0dGwgb2YgYSBrZXkuIGB0dGxgID0gMCBtZWFucyBpbmZpbml0ZSBsaWZldGltZS5cbiAgICAgICAgLy8gSWYgYHR0bGAgaXMgbm90IHBhc3NlZCB0aGUgZGVmYXVsdCB0dGwgaXMgdXNlZC5cbiAgICAgICAgLy8gSWYgYHR0bGAgPCAwIHRoZSBrZXkgd2lsbCBiZSBkZWxldGVkLlxuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleWAgKCBTdHJpbmcgfCBOdW1iZXIgKTogY2FjaGUga2V5IHRvIHJlc2V0IHRoZSB0dGwgdmFsdWVcbiAgICAgICAgLy8gKiBgdHRsYCAoIE51bWJlciApOiAoIG9wdGlvbmFsIC0+IG9wdGlvbnMuc3RkVFRMIHx8IDAgKSBUaGUgdGltZSB0byBsaXZlIGluIHNlY29uZHNcblxuICAgICAgICAvLyAqKlJldHVybioqXG5cbiAgICAgICAgLy8gKCBCb29sZW4gKToga2V5IGZvdW5kIGFuZCB0dGwgc2V0XG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUudHRsKCBcIm15S2V5XCIgKSAvLyB3aWxsIHNldCB0dGwgdG8gZGVmYXVsdCB0dGxcblxuICAgICAgICAvL1x0bXlDYWNoZS50dGwoIFwibXlLZXlcIiwgMTAwMCApXG5cbiAgICAgICAgdGhpcy50dGwgPSB0aGlzLnR0bC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBnZXRUdGxcblxuICAgICAgICAvLyByZWNlaXZlIHRoZSB0dGwgb2YgYSBrZXkuXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXkgdG8gY2hlY2sgdGhlIHR0bCB2YWx1ZVxuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIE51bWJlcnx1bmRlZmluZWQgKTogVGhlIHRpbWVzdGFtcCBpbiBtcyB3aGVuIHRoZSBrZXkgd2lsbCBleHBpcmUsIDAgaWYgaXQgd2lsbCBuZXZlciBleHBpcmUgb3IgdW5kZWZpbmVkIGlmIGl0IG5vdCBleGlzdHNcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5nZXRUdGwoIFwibXlLZXlcIiApXG5cbiAgICAgICAgdGhpcy5nZXRUdGwgPSB0aGlzLmdldFR0bC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBrZXlzXG5cbiAgICAgICAgLy8gbGlzdCBhbGwga2V5cyB3aXRoaW4gdGhpcyBjYWNoZVxuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIEFycmF5ICk6IEFuIGFycmF5IG9mIGFsbCBrZXlzXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIF9rZXlzID0gbXlDYWNoZS5rZXlzKClcblxuICAgICAgICAvLyAgICAgIyBbIFwiZm9vXCIsIFwiYmFyXCIsIFwiZml6elwiLCBcImJ1enpcIiwgXCJhbm90aGVyS2V5c1wiIF1cblxuICAgICAgICB0aGlzLmtleXMgPSB0aGlzLmtleXMuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgaGFzXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBrZXkgaXMgY2FjaGVkXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXkgdG8gY2hlY2sgdGhlIHR0bCB2YWx1ZVxuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIEJvb2xlYW4gKTogQSBib29sZWFuIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBrZXkgaXMgY2FjaGVkXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIF9leGlzdHMgPSBteUNhY2hlLmhhcygnbXlLZXknKVxuXG4gICAgICAgIC8vICAgICAjIHRydWVcblxuICAgICAgICB0aGlzLmhhcyA9IHRoaXMuaGFzLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGdldFN0YXRzXG5cbiAgICAgICAgLy8gZ2V0IHRoZSBzdGF0c1xuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vIC1cblxuICAgICAgICAvLyAqKlJldHVybioqXG5cbiAgICAgICAgLy8gKCBPYmplY3QgKTogU3RhdHMgZGF0YVxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vICAgICBteUNhY2hlLmdldFN0YXRzKClcbiAgICAgICAgLy8gICAgICMge1xuICAgICAgICAvLyAgICAgIyBoaXRzOiAwLFxuICAgICAgICAvLyAgICAgIyBtaXNzZXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtleXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtzaXplOiAwLFxuICAgICAgICAvLyAgICAgIyB2c2l6ZTogMFxuICAgICAgICAvLyAgICAgIyB9XG5cbiAgICAgICAgdGhpcy5nZXRTdGF0cyA9IHRoaXMuZ2V0U3RhdHMuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgZmx1c2hBbGxcblxuICAgICAgICAvLyBmbHVzaCB0aGUgd2hvbGUgZGF0YSBhbmQgcmVzZXQgdGhlIHN0YXRzXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZmx1c2hBbGwoKVxuXG4gICAgICAgIC8vICAgICBteUNhY2hlLmdldFN0YXRzKClcbiAgICAgICAgLy8gICAgICMge1xuICAgICAgICAvLyAgICAgIyBoaXRzOiAwLFxuICAgICAgICAvLyAgICAgIyBtaXNzZXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtleXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtzaXplOiAwLFxuICAgICAgICAvLyAgICAgIyB2c2l6ZTogMFxuICAgICAgICAvLyAgICAgIyB9XG5cbiAgICAgICAgdGhpcy5mbHVzaEFsbCA9IHRoaXMuZmx1c2hBbGwuYmluZCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIC8vICMjIGZsdXNoU3RhdHNcblxuICAgICAgICAvLyBmbHVzaCB0aGUgc3RhdHMgYW5kIHJlc2V0IGFsbCBjb3VudGVycyB0byAwXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZmx1c2hTdGF0cygpXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZ2V0U3RhdHMoKVxuICAgICAgICAvLyAgICAgIyB7XG4gICAgICAgIC8vICAgICAjIGhpdHM6IDAsXG4gICAgICAgIC8vICAgICAjIG1pc3NlczogMCxcbiAgICAgICAgLy8gICAgICMga2V5czogMCxcbiAgICAgICAgLy8gICAgICMga3NpemU6IDAsXG4gICAgICAgIC8vICAgICAjIHZzaXplOiAwXG4gICAgICAgIC8vICAgICAjIH1cblxuICAgICAgICB0aGlzLmZsdXNoU3RhdHMgPSB0aGlzLmZsdXNoU3RhdHMuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgY2xvc2VcblxuICAgICAgICAvLyBUaGlzIHdpbGwgY2xlYXIgdGhlIGludGVydmFsIHRpbWVvdXQgd2hpY2ggaXMgc2V0IG9uIGNoZWNrcGVyaW9kIG9wdGlvbi5cblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5jbG9zZSgpXG5cbiAgICAgICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2NoZWNrRGF0YVxuXG4gICAgICAgIC8vIGludGVybmFsIGhvdXNla2VlcGluZyBtZXRob2QuXG4gICAgICAgIC8vIENoZWNrIGFsbCB0aGUgY2FjaGVkIGRhdGEgYW5kIGRlbGV0ZSB0aGUgaW52YWxpZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5fY2hlY2tEYXRhID0gdGhpcy5fY2hlY2tEYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIF9jaGVja1xuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0aGUgY2hlY2sgdGhlIHZhbHVlLiBJZiBpdCdzIG5vdCB2YWxpZCBhbnkgbW9yZSBkZWxldGUgaXRcbiAgICAgICAgdGhpcy5fY2hlY2sgPSB0aGlzLl9jaGVjay5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfaXNJbnZhbGlkS2V5XG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGNoZWNrIGlmIHRoZSB0eXBlIG9mIGEga2V5IGlzIGVpdGhlciBgbnVtYmVyYCBvciBgc3RyaW5nYFxuICAgICAgICB0aGlzLl9pc0ludmFsaWRLZXkgPSB0aGlzLl9pc0ludmFsaWRLZXkuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX3dyYXBcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gd3JhcCBhIHZhbHVlIGluIGFuIG9iamVjdCB3aXRoIHNvbWUgbWV0YWRhdGFcbiAgICAgICAgdGhpcy5fd3JhcCA9IHRoaXMuX3dyYXAuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2dldFZhbExlbmd0aFxuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBjYWxjdWxhdGUgdGhlIHZhbHVlIGxlbmd0aFxuICAgICAgICB0aGlzLl9nZXRWYWxMZW5ndGggPSB0aGlzLl9nZXRWYWxMZW5ndGguYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2Vycm9yXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGhhbmRsZSBhbiBlcnJvciBtZXNzYWdlXG4gICAgICAgIHRoaXMuX2Vycm9yID0gdGhpcy5fZXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2luaXRFcnJvcnNcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gZ2VuZXJhdGUgZXJyb3IgbWVzc2FnZSB0ZW1wbGF0ZXNcbiAgICAgICAgdGhpcy5faW5pdEVycm9ycyA9IHRoaXMuX2luaXRFcnJvcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5faW5pdEVycm9ycygpO1xuICAgICAgICAvLyBjb250YWluZXIgZm9yIGNhY2hlZCBkYXRhXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICAvLyBtb2R1bGUgb3B0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAvLyBjb252ZXJ0IGFsbCBlbGVtZW50cyB0byBzdHJpbmdcbiAgICAgICAgICBmb3JjZVN0cmluZzogZmFsc2UsXG4gICAgICAgICAgLy8gdXNlZCBzdGFuZGFyZCBzaXplIGZvciBjYWxjdWxhdGluZyB2YWx1ZSBzaXplXG4gICAgICAgICAgb2JqZWN0VmFsdWVTaXplOiA4MCxcbiAgICAgICAgICBwcm9taXNlVmFsdWVTaXplOiA4MCxcbiAgICAgICAgICBhcnJheVZhbHVlU2l6ZTogNDAsXG4gICAgICAgICAgLy8gc3RhbmRhcmQgdGltZSB0byBsaXZlIGluIHNlY29uZHMuIDAgPSBpbmZpbml0eTtcbiAgICAgICAgICBzdGRUVEw6IDAsXG4gICAgICAgICAgLy8gdGltZSBpbiBzZWNvbmRzIHRvIGNoZWNrIGFsbCBkYXRhIGFuZCBkZWxldGUgZXhwaXJlZCBrZXlzXG4gICAgICAgICAgY2hlY2twZXJpb2Q6IDYwMCxcbiAgICAgICAgICAvLyBlbi9kaXNhYmxlIGNsb25pbmcgb2YgdmFyaWFibGVzLiBJZiBgdHJ1ZWAgeW91J2xsIGdldCBhIGNvcHkgb2YgdGhlIGNhY2hlZCB2YXJpYWJsZS4gSWYgYGZhbHNlYCB5b3UnbGwgc2F2ZSBhbmQgZ2V0IGp1c3QgdGhlIHJlZmVyZW5jZVxuICAgICAgICAgIHVzZUNsb25lczogdHJ1ZSxcbiAgICAgICAgICAvLyB3aGV0aGVyIHZhbHVlcyBzaG91bGQgYmUgZGVsZXRlZCBhdXRvbWF0aWNhbGx5IGF0IGV4cGlyYXRpb25cbiAgICAgICAgICBkZWxldGVPbkV4cGlyZTogdHJ1ZSxcbiAgICAgICAgICAvLyBlbmFibGUgbGVnYWN5IGNhbGxiYWNrc1xuICAgICAgICAgIGVuYWJsZUxlZ2FjeUNhbGxiYWNrczogZmFsc2UsXG4gICAgICAgICAgLy8gbWF4IGFtb3VudCBvZiBrZXlzIHRoYXQgYXJlIGJlaW5nIHN0b3JlZFxuICAgICAgICAgIG1heEtleXM6IC0xXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIC8vIGdlbmVyYXRlIGZ1bmN0aW9ucyB3aXRoIGNhbGxiYWNrcyAobGVnYWN5KVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUxlZ2FjeUNhbGxiYWNrcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIldBUk5JTkchIG5vZGUtY2FjaGUgbGVnYWN5IGNhbGxiYWNrIHN1cHBvcnQgd2lsbCBkcm9wIGluIHY2LnhcIik7XG4gICAgICAgICAgW1wiZ2V0XCIsIFwibWdldFwiLCBcInNldFwiLCBcImRlbFwiLCBcInR0bFwiLCBcImdldFR0bFwiLCBcImtleXNcIiwgXCJoYXNcIl0uZm9yRWFjaCgobWV0aG9kS2V5KSA9PiB7XG4gICAgICAgICAgICB2YXIgb2xkTWV0aG9kO1xuICAgICAgICAgICAgLy8gcmVmZXJlbmNlIHJlYWwgZnVuY3Rpb25cbiAgICAgICAgICAgIG9sZE1ldGhvZCA9IHRoaXNbbWV0aG9kS2V5XTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kS2V5XSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgdmFyIGNiLCBlcnIsIHJlZiwgcmVzO1xuICAgICAgICAgICAgICByZWYgPSBhcmdzLCBbLi4uYXJnc10gPSByZWYsIFtjYl0gPSBzcGxpY2UuY2FsbChhcmdzLCAtMSk7XG4gICAgICAgICAgICAgIC8vIHJldHVybiBhIGNhbGxiYWNrIGlmIGNiIGlzIGRlZmluZWQgYW5kIGEgZnVuY3Rpb25cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJlcyA9IG9sZE1ldGhvZCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgICAgICAgICAgICBlcnIgPSBlcnJvcjE7XG4gICAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkTWV0aG9kKC4uLmFyZ3MsIGNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGF0aXN0aWNzIGNvbnRhaW5lclxuICAgICAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgICAgIGhpdHM6IDAsXG4gICAgICAgICAgbWlzc2VzOiAwLFxuICAgICAgICAgIGtleXM6IDAsXG4gICAgICAgICAga3NpemU6IDAsXG4gICAgICAgICAgdnNpemU6IDBcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcHJlIGFsbG9jYXRlIHZhbGlkIGtleXR5cGVzIGFycmF5XG4gICAgICAgIHRoaXMudmFsaWRLZXlUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiXTtcbiAgICAgICAgLy8gaW5pdGFsaXplIGNoZWNraW5nIHBlcmlvZFxuICAgICAgICB0aGlzLl9jaGVja0RhdGEoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBfcmV0LCBlcnI7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGRhdGEgYW5kIGluY3JlbWV0IHN0YXRzXG4gICAgICAgIGlmICgodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkgJiYgdGhpcy5fY2hlY2soa2V5LCB0aGlzLmRhdGFba2V5XSkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRzLmhpdHMrKztcbiAgICAgICAgICBfcmV0ID0gdGhpcy5fdW53cmFwKHRoaXMuZGF0YVtrZXldKTtcbiAgICAgICAgICAvLyByZXR1cm4gZGF0YVxuICAgICAgICAgIHJldHVybiBfcmV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIG5vdCBmb3VuZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgdGhpcy5zdGF0cy5taXNzZXMrKztcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1nZXQoa2V5cykge1xuICAgICAgICB2YXIgX2VyciwgZXJyLCBpLCBrZXksIGxlbiwgb1JldDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBjb252ZXJ0IGEgc3RyaW5nIHRvIGFuIGFycmF5IG9mIG9uZSBrZXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgX2VyciA9IHRoaXMuX2Vycm9yKFwiRUtFWVNUWVBFXCIpO1xuICAgICAgICAgIHRocm93IF9lcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5lIHJldHVyblxuICAgICAgICBvUmV0ID0ge307XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZ2V0IGRhdGEgYW5kIGluY3JlbWVudCBzdGF0c1xuICAgICAgICAgIGlmICgodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkgJiYgdGhpcy5fY2hlY2soa2V5LCB0aGlzLmRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMuaGl0cysrO1xuICAgICAgICAgICAgb1JldFtrZXldID0gdGhpcy5fdW53cmFwKHRoaXMuZGF0YVtrZXldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbm90IGZvdW5kIHJldHVybiBhIGVycm9yXG4gICAgICAgICAgICB0aGlzLnN0YXRzLm1pc3NlcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gYWxsIGZvdW5kIGtleXNcbiAgICAgICAgcmV0dXJuIG9SZXQ7XG4gICAgICB9XG5cbiAgICAgIHNldChrZXksIHZhbHVlLCB0dGwpIHtcbiAgICAgICAgdmFyIF9lcnIsIGVyciwgZXhpc3RlbnQ7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgY2FjaGUgaXMgb3ZlcmZsb3dpbmdcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhLZXlzID4gLTEgJiYgdGhpcy5zdGF0cy5rZXlzID49IHRoaXMub3B0aW9ucy5tYXhLZXlzKSB7XG4gICAgICAgICAgX2VyciA9IHRoaXMuX2Vycm9yKFwiRUNBQ0hFRlVMTFwiKTtcbiAgICAgICAgICB0aHJvdyBfZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvcmNlIHRoZSBkYXRhIHRvIHN0cmluZ1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlU3RyaW5nICYmICF0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgZGVmYXVsdCB0dGwgaWYgbm90IHBhc3NlZFxuICAgICAgICBpZiAodHRsID09IG51bGwpIHtcbiAgICAgICAgICB0dGwgPSB0aGlzLm9wdGlvbnMuc3RkVFRMO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVybmFsIGhlbHBlciB2YXJpYWJsZXNcbiAgICAgICAgZXhpc3RlbnQgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nIGRhdGEgZnJvbSBzdGF0c1xuICAgICAgICBpZiAodGhpcy5kYXRhW2tleV0pIHtcbiAgICAgICAgICBleGlzdGVudCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGF0cy52c2l6ZSAtPSB0aGlzLl9nZXRWYWxMZW5ndGgodGhpcy5fdW53cmFwKHRoaXMuZGF0YVtrZXldLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSB0aGlzLl93cmFwKHZhbHVlLCB0dGwpO1xuICAgICAgICB0aGlzLnN0YXRzLnZzaXplICs9IHRoaXMuX2dldFZhbExlbmd0aCh2YWx1ZSk7XG4gICAgICAgIC8vIG9ubHkgYWRkIHRoZSBrZXlzIGFuZCBrZXktc2l6ZSBpZiB0aGUga2V5IGlzIG5ld1xuICAgICAgICBpZiAoIWV4aXN0ZW50KSB7XG4gICAgICAgICAgdGhpcy5zdGF0cy5rc2l6ZSArPSB0aGlzLl9nZXRLZXlMZW5ndGgoa2V5KTtcbiAgICAgICAgICB0aGlzLnN0YXRzLmtleXMrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJzZXRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICAgIC8vIHJldHVybiB0cnVlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBtc2V0KGtleVZhbHVlU2V0KSB7XG4gICAgICAgIHZhciBfZXJyLCBlcnIsIGksIGosIGtleSwga2V5VmFsdWVQYWlyLCBsZW4sIGxlbjEsIHR0bCwgdmFsO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGNhY2hlIGlzIG92ZXJmbG93aW5nXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4S2V5cyA+IC0xICYmIHRoaXMuc3RhdHMua2V5cyArIGtleVZhbHVlU2V0Lmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubWF4S2V5cykge1xuICAgICAgICAgIF9lcnIgPSB0aGlzLl9lcnJvcihcIkVDQUNIRUZVTExcIik7XG4gICAgICAgICAgdGhyb3cgX2VycjtcbiAgICAgICAgfVxuXG4vLyBsb29wIG92ZXIga2V5VmFsdWVTZXQgdG8gdmFsaWRhdGUga2V5IGFuZCB0dGxcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0ga2V5VmFsdWVTZXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBrZXlWYWx1ZVBhaXIgPSBrZXlWYWx1ZVNldFtpXTtcbiAgICAgICAgICAoe2tleSwgdmFsLCB0dGx9ID0ga2V5VmFsdWVQYWlyKTtcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyB0dGwgYW5kIGl0J3MgYSBudW1iZXJcbiAgICAgICAgICBpZiAodHRsICYmIHR5cGVvZiB0dGwgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIF9lcnIgPSB0aGlzLl9lcnJvcihcIkVUVExUWVBFXCIpO1xuICAgICAgICAgICAgdGhyb3cgX2VycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0ga2V5VmFsdWVTZXQubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAga2V5VmFsdWVQYWlyID0ga2V5VmFsdWVTZXRbal07XG4gICAgICAgICAgKHtrZXksIHZhbCwgdHRsfSA9IGtleVZhbHVlUGFpcik7XG4gICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWwsIHR0bCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGRlbChrZXlzKSB7XG4gICAgICAgIHZhciBkZWxDb3VudCwgZXJyLCBpLCBrZXksIGxlbiwgb2xkVmFsO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGNvbnZlcnQga2V5cyB0byBhbiBhcnJheSBvZiBpdHNlbGZcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAga2V5cyA9IFtrZXlzXTtcbiAgICAgICAgfVxuICAgICAgICBkZWxDb3VudCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb25seSBkZWxldGUgaWYgZXhpc3RlbnRcbiAgICAgICAgICBpZiAodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY2FsYyB0aGUgc3RhdHNcbiAgICAgICAgICAgIHRoaXMuc3RhdHMudnNpemUgLT0gdGhpcy5fZ2V0VmFsTGVuZ3RoKHRoaXMuX3Vud3JhcCh0aGlzLmRhdGFba2V5XSwgZmFsc2UpKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMua3NpemUgLT0gdGhpcy5fZ2V0S2V5TGVuZ3RoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRzLmtleXMtLTtcbiAgICAgICAgICAgIGRlbENvdW50Kys7XG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIHZhbHVlXG4gICAgICAgICAgICBvbGRWYWwgPSB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgICAgIC8vIHJldHVybiB0cnVlXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWxcIiwga2V5LCBvbGRWYWwudik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxDb3VudDtcbiAgICAgIH1cblxuICAgICAgdGFrZShrZXkpIHtcbiAgICAgICAgdmFyIF9yZXQ7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgX3JldCA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICgoX3JldCAhPSBudWxsKSkge1xuICAgICAgICAgIHRoaXMuZGVsKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXQ7XG4gICAgICB9XG5cbiAgICAgIHR0bChrZXksIHR0bCkge1xuICAgICAgICB2YXIgZXJyO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIHR0bCB8fCAodHRsID0gdGhpcy5vcHRpb25zLnN0ZFRUTCk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBleGlzdGVudCBkYXRhIGFuZCB1cGRhdGUgdGhlIHR0bCB2YWx1ZVxuICAgICAgICBpZiAoKHRoaXMuZGF0YVtrZXldICE9IG51bGwpICYmIHRoaXMuX2NoZWNrKGtleSwgdGhpcy5kYXRhW2tleV0pKSB7XG4gICAgICAgICAgLy8gaWYgdHRsIDwgMCBkZWxldGUgdGhlIGtleS4gb3RoZXJ3aXNlIHJlc2V0IHRoZSB2YWx1ZVxuICAgICAgICAgIGlmICh0dGwgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2tleV0gPSB0aGlzLl93cmFwKHRoaXMuZGF0YVtrZXldLnYsIHR0bCwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZXR1cm4gZmFsc2UgaWYga2V5IGhhcyBub3QgYmVlbiBmb3VuZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZXRUdGwoa2V5KSB7XG4gICAgICAgIHZhciBfdHRsLCBlcnI7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBleGlzdGFudCBkYXRhIGFuZCB1cGRhdGUgdGhlIHR0bCB2YWx1ZVxuICAgICAgICBpZiAoKHRoaXMuZGF0YVtrZXldICE9IG51bGwpICYmIHRoaXMuX2NoZWNrKGtleSwgdGhpcy5kYXRhW2tleV0pKSB7XG4gICAgICAgICAgX3R0bCA9IHRoaXMuZGF0YVtrZXldLnQ7XG4gICAgICAgICAgcmV0dXJuIF90dGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmV0dXJuIHVuZGVmaW5lZCBpZiBrZXkgaGFzIG5vdCBiZWVuIGZvdW5kXG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBrZXlzKCkge1xuICAgICAgICB2YXIgX2tleXM7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgX2tleXMgPSBPYmplY3Qua2V5cyh0aGlzLmRhdGEpO1xuICAgICAgICByZXR1cm4gX2tleXM7XG4gICAgICB9XG5cbiAgICAgIGhhcyhrZXkpIHtcbiAgICAgICAgdmFyIF9leGlzdHM7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgX2V4aXN0cyA9ICh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSAmJiB0aGlzLl9jaGVjayhrZXksIHRoaXMuZGF0YVtrZXldKTtcbiAgICAgICAgcmV0dXJuIF9leGlzdHM7XG4gICAgICB9XG5cbiAgICAgIGdldFN0YXRzKCkge1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRzO1xuICAgICAgfVxuXG4gICAgICBmbHVzaEFsbChfc3RhcnRQZXJpb2QgPSB0cnVlKSB7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gcGFyYW1ldGVyIGp1c3QgZm9yIHRlc3RpbmdcblxuICAgICAgICAvLyBzZXQgZGF0YSBlbXB0eVxuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgLy8gcmVzZXQgc3RhdHNcbiAgICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgICBoaXRzOiAwLFxuICAgICAgICAgIG1pc3NlczogMCxcbiAgICAgICAgICBrZXlzOiAwLFxuICAgICAgICAgIGtzaXplOiAwLFxuICAgICAgICAgIHZzaXplOiAwXG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlc2V0IGNoZWNrIHBlcmlvZFxuICAgICAgICB0aGlzLl9raWxsQ2hlY2tQZXJpb2QoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tEYXRhKF9zdGFydFBlcmlvZCk7XG4gICAgICAgIHRoaXMuZW1pdChcImZsdXNoXCIpO1xuICAgICAgfVxuXG4gICAgICBmbHVzaFN0YXRzKCkge1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIHJlc2V0IHN0YXRzXG4gICAgICAgIHRoaXMuc3RhdHMgPSB7XG4gICAgICAgICAgaGl0czogMCxcbiAgICAgICAgICBtaXNzZXM6IDAsXG4gICAgICAgICAga2V5czogMCxcbiAgICAgICAgICBrc2l6ZTogMCxcbiAgICAgICAgICB2c2l6ZTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoXCJmbHVzaF9zdGF0c1wiKTtcbiAgICAgIH1cblxuICAgICAgY2xvc2UoKSB7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgdGhpcy5fa2lsbENoZWNrUGVyaW9kKCk7XG4gICAgICB9XG5cbiAgICAgIF9jaGVja0RhdGEoc3RhcnRQZXJpb2QgPSB0cnVlKSB7XG4gICAgICAgIHZhciBrZXksIHJlZiwgdmFsdWU7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgcmVmID0gdGhpcy5kYXRhO1xuICAgICAgICAvLyBydW4gdGhlIGhvdXNla2VlcGluZyBtZXRob2RcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgICB0aGlzLl9jaGVjayhrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRQZXJpb2QgJiYgdGhpcy5vcHRpb25zLmNoZWNrcGVyaW9kID4gMCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9jaGVja0RhdGEsIHRoaXMub3B0aW9ucy5jaGVja3BlcmlvZCAqIDEwMDAsIHN0YXJ0UGVyaW9kKTtcbiAgICAgICAgICBpZiAoKHRoaXMuY2hlY2tUaW1lb3V0ICE9IG51bGwpICYmICh0aGlzLmNoZWNrVGltZW91dC51bnJlZiAhPSBudWxsKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1RpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gIyMgX2tpbGxDaGVja1BlcmlvZFxuXG4gICAgICAvLyBzdG9wIHRoZSBjaGVja2RhdGEgcGVyaW9kLiBPbmx5IG5lZWRlZCB0byBhYm9ydCB0aGUgc2NyaXB0IGluIHRlc3RpbmcgbW9kZS5cbiAgICAgIF9raWxsQ2hlY2tQZXJpb2QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aGlzLmNoZWNrVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2NoZWNrKGtleSwgZGF0YSkge1xuICAgICAgICB2YXIgX3JldHZhbDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBfcmV0dmFsID0gdHJ1ZTtcbiAgICAgICAgLy8gZGF0YSBpcyBpbnZhbGlkIGlmIHRoZSB0dGwgaXMgdG9vIG9sZCBhbmQgaXMgbm90IDBcbiAgICAgICAgLy8gY29uc29sZS5sb2cgZGF0YS50IDwgRGF0ZS5ub3coKSwgZGF0YS50LCBEYXRlLm5vdygpXG4gICAgICAgIGlmIChkYXRhLnQgIT09IDAgJiYgZGF0YS50IDwgRGF0ZS5ub3coKSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVsZXRlT25FeHBpcmUpIHtcbiAgICAgICAgICAgIF9yZXR2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVsKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdChcImV4cGlyZWRcIiwga2V5LCB0aGlzLl91bndyYXAoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmV0dmFsO1xuICAgICAgfVxuXG4gICAgICBfaXNJbnZhbGlkS2V5KGtleSkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIGlmIChyZWYgPSB0eXBlb2Yga2V5LCBpbmRleE9mLmNhbGwodGhpcy52YWxpZEtleVR5cGVzLCByZWYpIDwgMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcihcIkVLRVlUWVBFXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVvZiBrZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfd3JhcCh2YWx1ZSwgdHRsLCBhc0Nsb25lID0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGl2ZXRpbWUsIG5vdywgb1JldHVybiwgdHRsTXVsdGlwbGljYXRvcjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VDbG9uZXMpIHtcbiAgICAgICAgICBhc0Nsb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5lIHRoZSB0aW1lIHRvIGxpdmVcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGl2ZXRpbWUgPSAwO1xuICAgICAgICB0dGxNdWx0aXBsaWNhdG9yID0gMTAwMDtcbiAgICAgICAgLy8gdXNlIGdpdmVuIHR0bFxuICAgICAgICBpZiAodHRsID09PSAwKSB7XG4gICAgICAgICAgbGl2ZXRpbWUgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHR0bCkge1xuICAgICAgICAgIGxpdmV0aW1lID0gbm93ICsgKHR0bCAqIHR0bE11bHRpcGxpY2F0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBzdGFuZGFyZCB0dGxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0ZFRUTCA9PT0gMCkge1xuICAgICAgICAgICAgbGl2ZXRpbWUgPSB0aGlzLm9wdGlvbnMuc3RkVFRMO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXZldGltZSA9IG5vdyArICh0aGlzLm9wdGlvbnMuc3RkVFRMICogdHRsTXVsdGlwbGljYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiB0aGUgd3JhcHBlZCB2YWx1ZVxuICAgICAgICByZXR1cm4gb1JldHVybiA9IHtcbiAgICAgICAgICB0OiBsaXZldGltZSxcbiAgICAgICAgICB2OiBhc0Nsb25lID8gY2xvbmUodmFsdWUpIDogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gIyMgX3Vud3JhcFxuXG4gICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gZXh0cmFjdCBnZXQgdGhlIHZhbHVlIG91dCBvZiB0aGUgd3JhcHBlZCB2YWx1ZVxuICAgICAgX3Vud3JhcCh2YWx1ZSwgYXNDbG9uZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudXNlQ2xvbmVzKSB7XG4gICAgICAgICAgYXNDbG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS52ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYXNDbG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lKHZhbHVlLnYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vICMjIF9nZXRLZXlMZW5ndGhcblxuICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRoZSBjYWxjdWxhdGUgdGhlIGtleSBsZW5ndGhcbiAgICAgIF9nZXRLZXlMZW5ndGgoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIF9nZXRWYWxMZW5ndGgodmFsdWUpIHtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGEgU3RyaW5nIGdldCB0aGUgcmVhbCBsZW5ndGhcbiAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5mb3JjZVN0cmluZykge1xuICAgICAgICAgIC8vIGZvcmNlIHN0cmluZyBpZiBpdCdzIGRlZmluZWQgYW5kIG5vdCBwYXNzZWRcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBkYXRhIGlzIGFuIEFycmF5IG11bHRpcGx5IGVhY2ggZWxlbWVudCB3aXRoIGEgZGVmaW5lZCBkZWZhdWx0IGxlbmd0aFxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXJyYXlWYWx1ZVNpemUgKiB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICh2YWx1ZSAhPSBudWxsID8gdmFsdWUudGhlbiA6IHZvaWQgMCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIC8vIGlmIHRoZSBkYXRhIGlzIGEgUHJvbWlzZSwgdXNlIGRlZmluZWQgZGVmYXVsdFxuICAgICAgICAgIC8vIChjYW4ndCBjYWxjdWxhdGUgYWN0dWFsL3Jlc29sdmVkIHZhbHVlIHNpemUgc3luY2hyb25vdXNseSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnByb21pc2VWYWx1ZVNpemU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBCdWZmZXIgIT09IG51bGwgPyBCdWZmZXIuaXNCdWZmZXIodmFsdWUpIDogdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmICgodmFsdWUgIT0gbnVsbCkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgYW4gT2JqZWN0IG11bHRpcGx5IGVhY2ggZWxlbWVudCB3aXRoIGEgZGVmaW5lZCBkZWZhdWx0IGxlbmd0aFxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMub2JqZWN0VmFsdWVTaXplICogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmYXVsdCBmYWxsYmFja1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9lcnJvcih0eXBlLCBkYXRhID0ge30pIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSBlcnJvciBvYmplY3RcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgZXJyb3IubmFtZSA9IHR5cGU7XG4gICAgICAgIGVycm9yLmVycm9yY29kZSA9IHR5cGU7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSB0aGlzLkVSUk9SU1t0eXBlXSAhPSBudWxsID8gdGhpcy5FUlJPUlNbdHlwZV0oZGF0YSkgOiBcIi1cIjtcbiAgICAgICAgZXJyb3IuZGF0YSA9IGRhdGE7XG4gICAgICAgIC8vIHJldHVybiB0aGUgZXJyb3Igb2JqZWN0XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgX2luaXRFcnJvcnMoKSB7XG4gICAgICAgIHZhciBfZXJyTXNnLCBfZXJyVCwgcmVmO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIHRoaXMuRVJST1JTID0ge307XG4gICAgICAgIHJlZiA9IHRoaXMuX0VSUk9SUztcbiAgICAgICAgZm9yIChfZXJyVCBpbiByZWYpIHtcbiAgICAgICAgICBfZXJyTXNnID0gcmVmW19lcnJUXTtcbiAgICAgICAgICB0aGlzLkVSUk9SU1tfZXJyVF0gPSB0aGlzLmNyZWF0ZUVycm9yTWVzc2FnZShfZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjcmVhdGVFcnJvck1lc3NhZ2UoZXJyTXNnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGVyck1zZy5yZXBsYWNlKFwiX19rZXlcIiwgYXJncy50eXBlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBOb2RlQ2FjaGUucHJvdG90eXBlLl9FUlJPUlMgPSB7XG4gICAgICBcIkVOT1RGT1VORFwiOiBcIktleSBgX19rZXlgIG5vdCBmb3VuZFwiLFxuICAgICAgXCJFQ0FDSEVGVUxMXCI6IFwiQ2FjaGUgbWF4IGtleXMgYW1vdW50IGV4Y2VlZGVkXCIsXG4gICAgICBcIkVLRVlUWVBFXCI6IFwiVGhlIGtleSBhcmd1bWVudCBoYXMgdG8gYmUgb2YgdHlwZSBgc3RyaW5nYCBvciBgbnVtYmVyYC4gRm91bmQ6IGBfX2tleWBcIixcbiAgICAgIFwiRUtFWVNUWVBFXCI6IFwiVGhlIGtleXMgYXJndW1lbnQgaGFzIHRvIGJlIGFuIGFycmF5LlwiLFxuICAgICAgXCJFVFRMVFlQRVwiOiBcIlRoZSB0dGwgYXJndW1lbnQgaGFzIHRvIGJlIGEgbnVtYmVyLlwiXG4gICAgfTtcblxuICAgIHJldHVybiBOb2RlQ2FjaGU7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJOb2RlQ2FjaGUiLCJjbG9uZSIsInNwbGljZSIsImJvdW5kTWV0aG9kQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiRXJyb3IiLCJpbmRleE9mIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJnZXQiLCJiaW5kIiwibWdldCIsInNldCIsIm1zZXQiLCJkZWwiLCJ0YWtlIiwidHRsIiwiZ2V0VHRsIiwia2V5cyIsImhhcyIsImdldFN0YXRzIiwiZmx1c2hBbGwiLCJmbHVzaFN0YXRzIiwiY2xvc2UiLCJfY2hlY2tEYXRhIiwiX2NoZWNrIiwiX2lzSW52YWxpZEtleSIsIl93cmFwIiwiX2dldFZhbExlbmd0aCIsIl9lcnJvciIsIl9pbml0RXJyb3JzIiwiZGF0YSIsIk9iamVjdCIsImFzc2lnbiIsImZvcmNlU3RyaW5nIiwib2JqZWN0VmFsdWVTaXplIiwicHJvbWlzZVZhbHVlU2l6ZSIsImFycmF5VmFsdWVTaXplIiwic3RkVFRMIiwiY2hlY2twZXJpb2QiLCJ1c2VDbG9uZXMiLCJkZWxldGVPbkV4cGlyZSIsImVuYWJsZUxlZ2FjeUNhbGxiYWNrcyIsIm1heEtleXMiLCJjb25zb2xlIiwid2FybiIsImZvckVhY2giLCJtZXRob2RLZXkiLCJvbGRNZXRob2QiLCJhcmdzIiwiY2IiLCJlcnIiLCJyZWYiLCJyZXMiLCJjYWxsIiwiZXJyb3IxIiwic3RhdHMiLCJoaXRzIiwibWlzc2VzIiwia3NpemUiLCJ2c2l6ZSIsInZhbGlkS2V5VHlwZXMiLCJrZXkiLCJfcmV0IiwiX3Vud3JhcCIsIl9lcnIiLCJpIiwibGVuIiwib1JldCIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInZhbHVlIiwiZXhpc3RlbnQiLCJKU09OIiwic3RyaW5naWZ5IiwiX2dldEtleUxlbmd0aCIsImVtaXQiLCJrZXlWYWx1ZVNldCIsImoiLCJrZXlWYWx1ZVBhaXIiLCJsZW4xIiwidmFsIiwiZGVsQ291bnQiLCJvbGRWYWwiLCJ2IiwiX3R0bCIsInQiLCJfa2V5cyIsIl9leGlzdHMiLCJfc3RhcnRQZXJpb2QiLCJfa2lsbENoZWNrUGVyaW9kIiwic3RhcnRQZXJpb2QiLCJjaGVja1RpbWVvdXQiLCJzZXRUaW1lb3V0IiwidW5yZWYiLCJjbGVhclRpbWVvdXQiLCJfcmV0dmFsIiwiRGF0ZSIsIm5vdyIsInR5cGUiLCJhc0Nsb25lIiwibGl2ZXRpbWUiLCJvUmV0dXJuIiwidHRsTXVsdGlwbGljYXRvciIsInRvU3RyaW5nIiwidGhlbiIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiZXJyb3IiLCJuYW1lIiwiZXJyb3Jjb2RlIiwibWVzc2FnZSIsIkVSUk9SUyIsIl9lcnJNc2ciLCJfZXJyVCIsIl9FUlJPUlMiLCJjcmVhdGVFcnJvck1lc3NhZ2UiLCJlcnJNc2ciLCJyZXBsYWNlIiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-cache/lib/node_cache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-cache/index.js":
/*!******************************************!*\
  !*** ./node_modules/node-cache/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var exports;\n\n  exports = module.exports = __webpack_require__(/*! ./lib/node_cache */ \"(ssr)/./node_modules/node-cache/lib/node_cache.js\");\n\n  exports.version = '5.1.2';\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksaUhBQTRDOztBQUV4RDs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5pbWV0cml4Ly4vbm9kZV9tb2R1bGVzL25vZGUtY2FjaGUvaW5kZXguanM/ODVkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogbm9kZS1jYWNoZSA1LjEuMiAoIDIwMjAtMDctMDEgKVxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtY2FjaGUvbm9kZS1jYWNoZVxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtY2FjaGUvbm9kZS1jYWNoZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTWFpbnRhaW5lZCBieSAgKCAgKVxuKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIGV4cG9ydHM7XG5cbiAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvbm9kZV9jYWNoZScpO1xuXG4gIGV4cG9ydHMudmVyc2lvbiA9ICc1LjEuMic7XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-cache/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-cache/lib/node_cache.js":
/*!***************************************************!*\
  !*** ./node_modules/node-cache/lib/node_cache.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var EventEmitter, NodeCache, clone,\n    splice = [].splice,\n    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },\n    indexOf = [].indexOf;\n\n  clone = __webpack_require__(/*! clone */ \"(ssr)/./node_modules/clone/clone.js\");\n\n  EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\n  // generate superclass\n  module.exports = NodeCache = (function() {\n    class NodeCache extends EventEmitter {\n      constructor(options = {}) {\n        super();\n        // ## get\n\n        // get a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        this.get = this.get.bind(this);\n        // ## mget\n\n        // get multiple cached keys at once and change the stats\n\n        // **Parameters:**\n\n        // * `keys` ( String|Number[] ): an array of keys\n\n        // **Example:**\n\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        this.mget = this.mget.bind(this);\n        // ## set\n\n        // set a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n\n        // **Example:**\n\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        this.set = this.set.bind(this);\n        \n        // ## mset\n\n        // set multiple keys at once\n\n        // **Parameters:**\n\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n\n        // **Example:**\n\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        this.mset = this.mset.bind(this);\n        // ## del\n\n        // remove keys\n\n        // **Parameters:**\n\n        // * `keys` ( String |Â Number | String|Number[] ): cache key to delete or a array of cache keys\n\n        // **Return**\n\n        // ( Number ): Number of deleted keys\n\n        // **Example:**\n\n        //\tmyCache.del( \"myKey\" )\n\n        this.del = this.del.bind(this);\n        // ## take\n\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        this.take = this.take.bind(this);\n        // ## ttl\n\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n\n        // **Return**\n\n        // ( Boolen ): key found and ttl set\n\n        // **Example:**\n\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        this.ttl = this.ttl.bind(this);\n        // ## getTtl\n\n        // receive the ttl of a key.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n\n        // **Example:**\n\n        //\tmyCache.getTtl( \"myKey\" )\n\n        this.getTtl = this.getTtl.bind(this);\n        // ## keys\n\n        // list all keys within this cache\n\n        // **Return**\n\n        // ( Array ): An array of all keys\n\n        // **Example:**\n\n        //     _keys = myCache.keys()\n\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        this.keys = this.keys.bind(this);\n        // ## has\n\n        // Check if a key is cached\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Boolean ): A boolean that indicates if the key is cached\n\n        // **Example:**\n\n        //     _exists = myCache.has('myKey')\n\n        //     # true\n\n        this.has = this.has.bind(this);\n        // ## getStats\n\n        // get the stats\n\n        // **Parameters:**\n\n        // -\n\n        // **Return**\n\n        // ( Object ): Stats data\n\n        // **Example:**\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.getStats = this.getStats.bind(this);\n        // ## flushAll\n\n        // flush the whole data and reset the stats\n\n        // **Example:**\n\n        //     myCache.flushAll()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushAll = this.flushAll.bind(this);\n        \n        // ## flushStats\n\n        // flush the stats and reset all counters to 0\n\n        // **Example:**\n\n        //     myCache.flushStats()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushStats = this.flushStats.bind(this);\n        // ## close\n\n        // This will clear the interval timeout which is set on checkperiod option.\n\n        // **Example:**\n\n        //     myCache.close()\n\n        this.close = this.close.bind(this);\n        // ## _checkData\n\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n        this._checkData = this._checkData.bind(this);\n        // ## _check\n\n        // internal method the check the value. If it's not valid any more delete it\n        this._check = this._check.bind(this);\n        // ## _isInvalidKey\n\n        // internal method to check if the type of a key is either `number` or `string`\n        this._isInvalidKey = this._isInvalidKey.bind(this);\n        // ## _wrap\n\n        // internal method to wrap a value in an object with some metadata\n        this._wrap = this._wrap.bind(this);\n        // ## _getValLength\n\n        // internal method to calculate the value length\n        this._getValLength = this._getValLength.bind(this);\n        // ## _error\n\n        // internal method to handle an error message\n        this._error = this._error.bind(this);\n        // ## _initErrors\n\n        // internal method to generate error message templates\n        this._initErrors = this._initErrors.bind(this);\n        this.options = options;\n        this._initErrors();\n        // container for cached data\n        this.data = {};\n        // module options\n        this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, this.options);\n        // generate functions with callbacks (legacy)\n        if (this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach((methodKey) => {\n            var oldMethod;\n            // reference real function\n            oldMethod = this[methodKey];\n            this[methodKey] = function(...args) {\n              var cb, err, ref, res;\n              ref = args, [...args] = ref, [cb] = splice.call(args, -1);\n              // return a callback if cb is defined and a function\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod(...args);\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod(...args, cb);\n              }\n            };\n          });\n        }\n        // statistics container\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // pre allocate valid keytypes array\n        this.validKeyTypes = [\"string\", \"number\"];\n        // initalize checking period\n        this._checkData();\n        return;\n      }\n\n      get(key) {\n        var _ret, err;\n        boundMethodCheck(this, NodeCache);\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // get data and incremet stats\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          this.stats.hits++;\n          _ret = this._unwrap(this.data[key]);\n          // return data\n          return _ret;\n        } else {\n          // if not found return undefined\n          this.stats.misses++;\n          return void 0;\n        }\n      }\n\n      mget(keys) {\n        var _err, err, i, key, len, oRet;\n        boundMethodCheck(this, NodeCache);\n        // convert a string to an array of one key\n        if (!Array.isArray(keys)) {\n          _err = this._error(\"EKEYSTYPE\");\n          throw _err;\n        }\n        // define return\n        oRet = {};\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // get data and increment stats\n          if ((this.data[key] != null) && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            oRet[key] = this._unwrap(this.data[key]);\n          } else {\n            // if not found return a error\n            this.stats.misses++;\n          }\n        }\n        // return all found keys\n        return oRet;\n      }\n\n      set(key, value, ttl) {\n        var _err, err, existent;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n        // force the data to string\n        if (this.options.forceString && !typeof value === \"string\") {\n          value = JSON.stringify(value);\n        }\n        // set default ttl if not passed\n        if (ttl == null) {\n          ttl = this.options.stdTTL;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // internal helper variables\n        existent = false;\n        // remove existing data from stats\n        if (this.data[key]) {\n          existent = true;\n          this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n        }\n        // set the value\n        this.data[key] = this._wrap(value, ttl);\n        this.stats.vsize += this._getValLength(value);\n        // only add the keys and key-size if the key is new\n        if (!existent) {\n          this.stats.ksize += this._getKeyLength(key);\n          this.stats.keys++;\n        }\n        this.emit(\"set\", key, value);\n        // return true\n        return true;\n      }\n\n      mset(keyValueSet) {\n        var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n\n// loop over keyValueSet to validate key and ttl\n        for (i = 0, len = keyValueSet.length; i < len; i++) {\n          keyValuePair = keyValueSet[i];\n          ({key, val, ttl} = keyValuePair);\n          // check if there is ttl and it's a number\n          if (ttl && typeof ttl !== \"number\") {\n            _err = this._error(\"ETTLTYPE\");\n            throw _err;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n        }\n        for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n          keyValuePair = keyValueSet[j];\n          ({key, val, ttl} = keyValuePair);\n          this.set(key, val, ttl);\n        }\n        return true;\n      }\n\n      del(keys) {\n        var delCount, err, i, key, len, oldVal;\n        boundMethodCheck(this, NodeCache);\n        // convert keys to an array of itself\n        if (!Array.isArray(keys)) {\n          keys = [keys];\n        }\n        delCount = 0;\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // only delete if existent\n          if (this.data[key] != null) {\n            // calc the stats\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n            this.stats.ksize -= this._getKeyLength(key);\n            this.stats.keys--;\n            delCount++;\n            // delete the value\n            oldVal = this.data[key];\n            delete this.data[key];\n            // return true\n            this.emit(\"del\", key, oldVal.v);\n          }\n        }\n        return delCount;\n      }\n\n      take(key) {\n        var _ret;\n        boundMethodCheck(this, NodeCache);\n        _ret = this.get(key);\n        if ((_ret != null)) {\n          this.del(key);\n        }\n        return _ret;\n      }\n\n      ttl(key, ttl) {\n        var err;\n        boundMethodCheck(this, NodeCache);\n        ttl || (ttl = this.options.stdTTL);\n        if (!key) {\n          return false;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existent data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          // if ttl < 0 delete the key. otherwise reset the value\n          if (ttl >= 0) {\n            this.data[key] = this._wrap(this.data[key].v, ttl, false);\n          } else {\n            this.del(key);\n          }\n          return true;\n        } else {\n          // return false if key has not been found\n          return false;\n        }\n      }\n\n      getTtl(key) {\n        var _ttl, err;\n        boundMethodCheck(this, NodeCache);\n        if (!key) {\n          return void 0;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existant data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          _ttl = this.data[key].t;\n          return _ttl;\n        } else {\n          // return undefined if key has not been found\n          return void 0;\n        }\n      }\n\n      keys() {\n        var _keys;\n        boundMethodCheck(this, NodeCache);\n        _keys = Object.keys(this.data);\n        return _keys;\n      }\n\n      has(key) {\n        var _exists;\n        boundMethodCheck(this, NodeCache);\n        _exists = (this.data[key] != null) && this._check(key, this.data[key]);\n        return _exists;\n      }\n\n      getStats() {\n        boundMethodCheck(this, NodeCache);\n        return this.stats;\n      }\n\n      flushAll(_startPeriod = true) {\n        boundMethodCheck(this, NodeCache);\n        // parameter just for testing\n\n        // set data empty\n        this.data = {};\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // reset check period\n        this._killCheckPeriod();\n        this._checkData(_startPeriod);\n        this.emit(\"flush\");\n      }\n\n      flushStats() {\n        boundMethodCheck(this, NodeCache);\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        this.emit(\"flush_stats\");\n      }\n\n      close() {\n        boundMethodCheck(this, NodeCache);\n        this._killCheckPeriod();\n      }\n\n      _checkData(startPeriod = true) {\n        var key, ref, value;\n        boundMethodCheck(this, NodeCache);\n        ref = this.data;\n        // run the housekeeping method\n        for (key in ref) {\n          value = ref[key];\n          this._check(key, value);\n        }\n        if (startPeriod && this.options.checkperiod > 0) {\n          this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n          if ((this.checkTimeout != null) && (this.checkTimeout.unref != null)) {\n            this.checkTimeout.unref();\n          }\n        }\n      }\n\n      // ## _killCheckPeriod\n\n      // stop the checkdata period. Only needed to abort the script in testing mode.\n      _killCheckPeriod() {\n        if (this.checkTimeout != null) {\n          return clearTimeout(this.checkTimeout);\n        }\n      }\n\n      _check(key, data) {\n        var _retval;\n        boundMethodCheck(this, NodeCache);\n        _retval = true;\n        // data is invalid if the ttl is too old and is not 0\n        // console.log data.t < Date.now(), data.t, Date.now()\n        if (data.t !== 0 && data.t < Date.now()) {\n          if (this.options.deleteOnExpire) {\n            _retval = false;\n            this.del(key);\n          }\n          this.emit(\"expired\", key, this._unwrap(data));\n        }\n        return _retval;\n      }\n\n      _isInvalidKey(key) {\n        var ref;\n        boundMethodCheck(this, NodeCache);\n        if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n          return this._error(\"EKEYTYPE\", {\n            type: typeof key\n          });\n        }\n      }\n\n      _wrap(value, ttl, asClone = true) {\n        var livetime, now, oReturn, ttlMultiplicator;\n        boundMethodCheck(this, NodeCache);\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        // define the time to live\n        now = Date.now();\n        livetime = 0;\n        ttlMultiplicator = 1000;\n        // use given ttl\n        if (ttl === 0) {\n          livetime = 0;\n        } else if (ttl) {\n          livetime = now + (ttl * ttlMultiplicator);\n        } else {\n          // use standard ttl\n          if (this.options.stdTTL === 0) {\n            livetime = this.options.stdTTL;\n          } else {\n            livetime = now + (this.options.stdTTL * ttlMultiplicator);\n          }\n        }\n        // return the wrapped value\n        return oReturn = {\n          t: livetime,\n          v: asClone ? clone(value) : value\n        };\n      }\n\n      // ## _unwrap\n\n      // internal method to extract get the value out of the wrapped value\n      _unwrap(value, asClone = true) {\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        if (value.v != null) {\n          if (asClone) {\n            return clone(value.v);\n          } else {\n            return value.v;\n          }\n        }\n        return null;\n      }\n\n      // ## _getKeyLength\n\n      // internal method the calculate the key length\n      _getKeyLength(key) {\n        return key.toString().length;\n      }\n\n      _getValLength(value) {\n        boundMethodCheck(this, NodeCache);\n        if (typeof value === \"string\") {\n          // if the value is a String get the real length\n          return value.length;\n        } else if (this.options.forceString) {\n          // force string if it's defined and not passed\n          return JSON.stringify(value).length;\n        } else if (Array.isArray(value)) {\n          // if the data is an Array multiply each element with a defined default length\n          return this.options.arrayValueSize * value.length;\n        } else if (typeof value === \"number\") {\n          return 8;\n        } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n          // if the data is a Promise, use defined default\n          // (can't calculate actual/resolved value size synchronously)\n          return this.options.promiseValueSize;\n        } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n          return value.length;\n        } else if ((value != null) && typeof value === \"object\") {\n          // if the data is an Object multiply each element with a defined default length\n          return this.options.objectValueSize * Object.keys(value).length;\n        } else if (typeof value === \"boolean\") {\n          return 8;\n        } else {\n          // default fallback\n          return 0;\n        }\n      }\n\n      _error(type, data = {}) {\n        var error;\n        boundMethodCheck(this, NodeCache);\n        // generate the error object\n        error = new Error();\n        error.name = type;\n        error.errorcode = type;\n        error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n        error.data = data;\n        // return the error object\n        return error;\n      }\n\n      _initErrors() {\n        var _errMsg, _errT, ref;\n        boundMethodCheck(this, NodeCache);\n        this.ERRORS = {};\n        ref = this._ERRORS;\n        for (_errT in ref) {\n          _errMsg = ref[_errT];\n          this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n        }\n      }\n\n      createErrorMessage(errMsg) {\n        return function(args) {\n          return errMsg.replace(\"__key\", args.type);\n        };\n      }\n\n    };\n\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n\n    return NodeCache;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9saWIvbm9kZV9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMENBQTBDLHFFQUFxRTtBQUN4Szs7QUFFQSxVQUFVLG1CQUFPLENBQUMsa0RBQU87O0FBRXpCLGlCQUFpQiwwREFBOEI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5pbWV0cml4Ly4vbm9kZV9tb2R1bGVzL25vZGUtY2FjaGUvbGliL25vZGVfY2FjaGUuanM/ZmFlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogbm9kZS1jYWNoZSA1LjEuMiAoIDIwMjAtMDctMDEgKVxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtY2FjaGUvbm9kZS1jYWNoZVxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtY2FjaGUvbm9kZS1jYWNoZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTWFpbnRhaW5lZCBieSAgKCAgKVxuKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIEV2ZW50RW1pdHRlciwgTm9kZUNhY2hlLCBjbG9uZSxcbiAgICBzcGxpY2UgPSBbXS5zcGxpY2UsXG4gICAgYm91bmRNZXRob2RDaGVjayA9IGZ1bmN0aW9uKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kIGluc3RhbmNlIG1ldGhvZCBhY2Nlc3NlZCBiZWZvcmUgYmluZGluZycpOyB9IH0sXG4gICAgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbiAgY2xvbmUgPSByZXF1aXJlKFwiY2xvbmVcIik7XG5cbiAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4gIC8vIGdlbmVyYXRlIHN1cGVyY2xhc3NcbiAgbW9kdWxlLmV4cG9ydHMgPSBOb2RlQ2FjaGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgTm9kZUNhY2hlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyAjIyBnZXRcblxuICAgICAgICAvLyBnZXQgYSBjYWNoZWQga2V5IGFuZCBjaGFuZ2UgdGhlIHN0YXRzXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXlcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5nZXQgXCJteUtleVwiLCAoIGVyciwgdmFsIClcblxuICAgICAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIG1nZXRcblxuICAgICAgICAvLyBnZXQgbXVsdGlwbGUgY2FjaGVkIGtleXMgYXQgb25jZSBhbmQgY2hhbmdlIHRoZSBzdGF0c1xuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleXNgICggU3RyaW5nfE51bWJlcltdICk6IGFuIGFycmF5IG9mIGtleXNcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5tZ2V0IFsgXCJmb29cIiwgXCJiYXJcIiBdXG5cbiAgICAgICAgdGhpcy5tZ2V0ID0gdGhpcy5tZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIHNldFxuXG4gICAgICAgIC8vIHNldCBhIGNhY2hlZCBrZXkgYW5kIGNoYW5nZSB0aGUgc3RhdHNcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleVxuICAgICAgICAvLyAqIGB2YWx1ZWAgKCBBbnkgKTogQSBlbGVtZW50IHRvIGNhY2hlLiBJZiB0aGUgb3B0aW9uIGBvcHRpb24uZm9yY2VTdHJpbmdgIGlzIGB0cnVlYCB0aGUgbW9kdWxlIHRyeXMgdG8gdHJhbnNsYXRlIGl0IHRvIGEgc2VyaWFsaXplZCBKU09OXG4gICAgICAgIC8vICogYFsgdHRsIF1gICggTnVtYmVyIHwgU3RyaW5nICk6ICggb3B0aW9uYWwgKSBUaGUgdGltZSB0byBsaXZlIGluIHNlY29uZHMuXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUuc2V0IFwibXlLZXlcIiwgXCJteV9TdHJpbmcgVmFsdWVcIlxuXG4gICAgICAgIC8vXHRteUNhY2hlLnNldCBcIm15S2V5XCIsIFwibXlfU3RyaW5nIFZhbHVlXCIsIDEwXG5cbiAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldC5iaW5kKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gIyMgbXNldFxuXG4gICAgICAgIC8vIHNldCBtdWx0aXBsZSBrZXlzIGF0IG9uY2VcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlWYWx1ZVNldGAgKCBPYmplY3RbXSApOiBhbiBhcnJheSBvZiBvYmplY3Qgd2hpY2ggaW5jbHVkZXMga2V5LHZhbHVlIGFuZCB0dGxcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5tc2V0KFxuICAgICAgICAvL1x0XHRbXG4gICAgICAgIC8vXHRcdFx0e1xuICAgICAgICAvL1x0XHRcdFx0a2V5OiBcIm15S2V5XCIsXG4gICAgICAgIC8vXHRcdFx0XHR2YWw6IFwibXlWYWx1ZVwiLFxuICAgICAgICAvL1x0XHRcdFx0dHRsOiBbdHRsIGluIHNlY29uZHNdXG4gICAgICAgIC8vXHRcdFx0fVxuICAgICAgICAvL1x0XHRdKVxuXG4gICAgICAgIHRoaXMubXNldCA9IHRoaXMubXNldC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBkZWxcblxuICAgICAgICAvLyByZW1vdmUga2V5c1xuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleXNgICggU3RyaW5nIHzCoE51bWJlciB8IFN0cmluZ3xOdW1iZXJbXSApOiBjYWNoZSBrZXkgdG8gZGVsZXRlIG9yIGEgYXJyYXkgb2YgY2FjaGUga2V5c1xuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIE51bWJlciApOiBOdW1iZXIgb2YgZGVsZXRlZCBrZXlzXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUuZGVsKCBcIm15S2V5XCIgKVxuXG4gICAgICAgIHRoaXMuZGVsID0gdGhpcy5kZWwuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgdGFrZVxuXG4gICAgICAgIC8vIGdldCB0aGUgY2FjaGVkIHZhbHVlIGFuZCByZW1vdmUgdGhlIGtleSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgICAgLy8gRXF1aXZhbGVudCB0byBjYWxsaW5nIGBnZXQoa2V5KWAgKyBgZGVsKGtleSlgLlxuICAgICAgICAvLyBVc2VmdWwgZm9yIGltcGxlbWVudGluZyBgc2luZ2xlIHVzZWAgbWVjaGFuaXNtIHN1Y2ggYXMgT1RQLCB3aGVyZSBvbmNlIGEgdmFsdWUgaXMgcmVhZCBpdCB3aWxsIGJlY29tZSBvYnNvbGV0ZS5cblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleVxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLnRha2UgXCJteUtleVwiLCAoIGVyciwgdmFsIClcblxuICAgICAgICB0aGlzLnRha2UgPSB0aGlzLnRha2UuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgdHRsXG5cbiAgICAgICAgLy8gcmVzZXQgb3IgcmVkZWZpbmUgdGhlIHR0bCBvZiBhIGtleS4gYHR0bGAgPSAwIG1lYW5zIGluZmluaXRlIGxpZmV0aW1lLlxuICAgICAgICAvLyBJZiBgdHRsYCBpcyBub3QgcGFzc2VkIHRoZSBkZWZhdWx0IHR0bCBpcyB1c2VkLlxuICAgICAgICAvLyBJZiBgdHRsYCA8IDAgdGhlIGtleSB3aWxsIGJlIGRlbGV0ZWQuXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXkgdG8gcmVzZXQgdGhlIHR0bCB2YWx1ZVxuICAgICAgICAvLyAqIGB0dGxgICggTnVtYmVyICk6ICggb3B0aW9uYWwgLT4gb3B0aW9ucy5zdGRUVEwgfHwgMCApIFRoZSB0aW1lIHRvIGxpdmUgaW4gc2Vjb25kc1xuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIEJvb2xlbiApOiBrZXkgZm91bmQgYW5kIHR0bCBzZXRcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS50dGwoIFwibXlLZXlcIiApIC8vIHdpbGwgc2V0IHR0bCB0byBkZWZhdWx0IHR0bFxuXG4gICAgICAgIC8vXHRteUNhY2hlLnR0bCggXCJteUtleVwiLCAxMDAwIClcblxuICAgICAgICB0aGlzLnR0bCA9IHRoaXMudHRsLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGdldFR0bFxuXG4gICAgICAgIC8vIHJlY2VpdmUgdGhlIHR0bCBvZiBhIGtleS5cblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleSB0byBjaGVjayB0aGUgdHRsIHZhbHVlXG5cbiAgICAgICAgLy8gKipSZXR1cm4qKlxuXG4gICAgICAgIC8vICggTnVtYmVyfHVuZGVmaW5lZCApOiBUaGUgdGltZXN0YW1wIGluIG1zIHdoZW4gdGhlIGtleSB3aWxsIGV4cGlyZSwgMCBpZiBpdCB3aWxsIG5ldmVyIGV4cGlyZSBvciB1bmRlZmluZWQgaWYgaXQgbm90IGV4aXN0c1xuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLmdldFR0bCggXCJteUtleVwiIClcblxuICAgICAgICB0aGlzLmdldFR0bCA9IHRoaXMuZ2V0VHRsLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGtleXNcblxuICAgICAgICAvLyBsaXN0IGFsbCBrZXlzIHdpdGhpbiB0aGlzIGNhY2hlXG5cbiAgICAgICAgLy8gKipSZXR1cm4qKlxuXG4gICAgICAgIC8vICggQXJyYXkgKTogQW4gYXJyYXkgb2YgYWxsIGtleXNcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgX2tleXMgPSBteUNhY2hlLmtleXMoKVxuXG4gICAgICAgIC8vICAgICAjIFsgXCJmb29cIiwgXCJiYXJcIiwgXCJmaXp6XCIsIFwiYnV6elwiLCBcImFub3RoZXJLZXlzXCIgXVxuXG4gICAgICAgIHRoaXMua2V5cyA9IHRoaXMua2V5cy5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBoYXNcblxuICAgICAgICAvLyBDaGVjayBpZiBhIGtleSBpcyBjYWNoZWRcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleSB0byBjaGVjayB0aGUgdHRsIHZhbHVlXG5cbiAgICAgICAgLy8gKipSZXR1cm4qKlxuXG4gICAgICAgIC8vICggQm9vbGVhbiApOiBBIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGtleSBpcyBjYWNoZWRcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgX2V4aXN0cyA9IG15Q2FjaGUuaGFzKCdteUtleScpXG5cbiAgICAgICAgLy8gICAgICMgdHJ1ZVxuXG4gICAgICAgIHRoaXMuaGFzID0gdGhpcy5oYXMuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgZ2V0U3RhdHNcblxuICAgICAgICAvLyBnZXQgdGhlIHN0YXRzXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gLVxuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIE9iamVjdCApOiBTdGF0cyBkYXRhXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZ2V0U3RhdHMoKVxuICAgICAgICAvLyAgICAgIyB7XG4gICAgICAgIC8vICAgICAjIGhpdHM6IDAsXG4gICAgICAgIC8vICAgICAjIG1pc3NlczogMCxcbiAgICAgICAgLy8gICAgICMga2V5czogMCxcbiAgICAgICAgLy8gICAgICMga3NpemU6IDAsXG4gICAgICAgIC8vICAgICAjIHZzaXplOiAwXG4gICAgICAgIC8vICAgICAjIH1cblxuICAgICAgICB0aGlzLmdldFN0YXRzID0gdGhpcy5nZXRTdGF0cy5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBmbHVzaEFsbFxuXG4gICAgICAgIC8vIGZsdXNoIHRoZSB3aG9sZSBkYXRhIGFuZCByZXNldCB0aGUgc3RhdHNcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5mbHVzaEFsbCgpXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZ2V0U3RhdHMoKVxuICAgICAgICAvLyAgICAgIyB7XG4gICAgICAgIC8vICAgICAjIGhpdHM6IDAsXG4gICAgICAgIC8vICAgICAjIG1pc3NlczogMCxcbiAgICAgICAgLy8gICAgICMga2V5czogMCxcbiAgICAgICAgLy8gICAgICMga3NpemU6IDAsXG4gICAgICAgIC8vICAgICAjIHZzaXplOiAwXG4gICAgICAgIC8vICAgICAjIH1cblxuICAgICAgICB0aGlzLmZsdXNoQWxsID0gdGhpcy5mbHVzaEFsbC5iaW5kKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gIyMgZmx1c2hTdGF0c1xuXG4gICAgICAgIC8vIGZsdXNoIHRoZSBzdGF0cyBhbmQgcmVzZXQgYWxsIGNvdW50ZXJzIHRvIDBcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5mbHVzaFN0YXRzKClcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5nZXRTdGF0cygpXG4gICAgICAgIC8vICAgICAjIHtcbiAgICAgICAgLy8gICAgICMgaGl0czogMCxcbiAgICAgICAgLy8gICAgICMgbWlzc2VzOiAwLFxuICAgICAgICAvLyAgICAgIyBrZXlzOiAwLFxuICAgICAgICAvLyAgICAgIyBrc2l6ZTogMCxcbiAgICAgICAgLy8gICAgICMgdnNpemU6IDBcbiAgICAgICAgLy8gICAgICMgfVxuXG4gICAgICAgIHRoaXMuZmx1c2hTdGF0cyA9IHRoaXMuZmx1c2hTdGF0cy5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBjbG9zZVxuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBjbGVhciB0aGUgaW50ZXJ2YWwgdGltZW91dCB3aGljaCBpcyBzZXQgb24gY2hlY2twZXJpb2Qgb3B0aW9uLlxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vICAgICBteUNhY2hlLmNsb3NlKClcblxuICAgICAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfY2hlY2tEYXRhXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgaG91c2VrZWVwaW5nIG1ldGhvZC5cbiAgICAgICAgLy8gQ2hlY2sgYWxsIHRoZSBjYWNoZWQgZGF0YSBhbmQgZGVsZXRlIHRoZSBpbnZhbGlkIHZhbHVlc1xuICAgICAgICB0aGlzLl9jaGVja0RhdGEgPSB0aGlzLl9jaGVja0RhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2NoZWNrXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRoZSBjaGVjayB0aGUgdmFsdWUuIElmIGl0J3Mgbm90IHZhbGlkIGFueSBtb3JlIGRlbGV0ZSBpdFxuICAgICAgICB0aGlzLl9jaGVjayA9IHRoaXMuX2NoZWNrLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIF9pc0ludmFsaWRLZXlcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gY2hlY2sgaWYgdGhlIHR5cGUgb2YgYSBrZXkgaXMgZWl0aGVyIGBudW1iZXJgIG9yIGBzdHJpbmdgXG4gICAgICAgIHRoaXMuX2lzSW52YWxpZEtleSA9IHRoaXMuX2lzSW52YWxpZEtleS5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfd3JhcFxuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byB3cmFwIGEgdmFsdWUgaW4gYW4gb2JqZWN0IHdpdGggc29tZSBtZXRhZGF0YVxuICAgICAgICB0aGlzLl93cmFwID0gdGhpcy5fd3JhcC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfZ2V0VmFsTGVuZ3RoXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgdmFsdWUgbGVuZ3RoXG4gICAgICAgIHRoaXMuX2dldFZhbExlbmd0aCA9IHRoaXMuX2dldFZhbExlbmd0aC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfZXJyb3JcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gaGFuZGxlIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5fZXJyb3IgPSB0aGlzLl9lcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfaW5pdEVycm9yc1xuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBnZW5lcmF0ZSBlcnJvciBtZXNzYWdlIHRlbXBsYXRlc1xuICAgICAgICB0aGlzLl9pbml0RXJyb3JzID0gdGhpcy5faW5pdEVycm9ycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9pbml0RXJyb3JzKCk7XG4gICAgICAgIC8vIGNvbnRhaW5lciBmb3IgY2FjaGVkIGRhdGFcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIC8vIG1vZHVsZSBvcHRpb25zXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIC8vIGNvbnZlcnQgYWxsIGVsZW1lbnRzIHRvIHN0cmluZ1xuICAgICAgICAgIGZvcmNlU3RyaW5nOiBmYWxzZSxcbiAgICAgICAgICAvLyB1c2VkIHN0YW5kYXJkIHNpemUgZm9yIGNhbGN1bGF0aW5nIHZhbHVlIHNpemVcbiAgICAgICAgICBvYmplY3RWYWx1ZVNpemU6IDgwLFxuICAgICAgICAgIHByb21pc2VWYWx1ZVNpemU6IDgwLFxuICAgICAgICAgIGFycmF5VmFsdWVTaXplOiA0MCxcbiAgICAgICAgICAvLyBzdGFuZGFyZCB0aW1lIHRvIGxpdmUgaW4gc2Vjb25kcy4gMCA9IGluZmluaXR5O1xuICAgICAgICAgIHN0ZFRUTDogMCxcbiAgICAgICAgICAvLyB0aW1lIGluIHNlY29uZHMgdG8gY2hlY2sgYWxsIGRhdGEgYW5kIGRlbGV0ZSBleHBpcmVkIGtleXNcbiAgICAgICAgICBjaGVja3BlcmlvZDogNjAwLFxuICAgICAgICAgIC8vIGVuL2Rpc2FibGUgY2xvbmluZyBvZiB2YXJpYWJsZXMuIElmIGB0cnVlYCB5b3UnbGwgZ2V0IGEgY29weSBvZiB0aGUgY2FjaGVkIHZhcmlhYmxlLiBJZiBgZmFsc2VgIHlvdSdsbCBzYXZlIGFuZCBnZXQganVzdCB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgdXNlQ2xvbmVzOiB0cnVlLFxuICAgICAgICAgIC8vIHdoZXRoZXIgdmFsdWVzIHNob3VsZCBiZSBkZWxldGVkIGF1dG9tYXRpY2FsbHkgYXQgZXhwaXJhdGlvblxuICAgICAgICAgIGRlbGV0ZU9uRXhwaXJlOiB0cnVlLFxuICAgICAgICAgIC8vIGVuYWJsZSBsZWdhY3kgY2FsbGJhY2tzXG4gICAgICAgICAgZW5hYmxlTGVnYWN5Q2FsbGJhY2tzOiBmYWxzZSxcbiAgICAgICAgICAvLyBtYXggYW1vdW50IG9mIGtleXMgdGhhdCBhcmUgYmVpbmcgc3RvcmVkXG4gICAgICAgICAgbWF4S2V5czogLTFcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgZnVuY3Rpb25zIHdpdGggY2FsbGJhY2tzIChsZWdhY3kpXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlTGVnYWN5Q2FsbGJhY2tzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORyEgbm9kZS1jYWNoZSBsZWdhY3kgY2FsbGJhY2sgc3VwcG9ydCB3aWxsIGRyb3AgaW4gdjYueFwiKTtcbiAgICAgICAgICBbXCJnZXRcIiwgXCJtZ2V0XCIsIFwic2V0XCIsIFwiZGVsXCIsIFwidHRsXCIsIFwiZ2V0VHRsXCIsIFwia2V5c1wiLCBcImhhc1wiXS5mb3JFYWNoKChtZXRob2RLZXkpID0+IHtcbiAgICAgICAgICAgIHZhciBvbGRNZXRob2Q7XG4gICAgICAgICAgICAvLyByZWZlcmVuY2UgcmVhbCBmdW5jdGlvblxuICAgICAgICAgICAgb2xkTWV0aG9kID0gdGhpc1ttZXRob2RLZXldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2RLZXldID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgICAgICB2YXIgY2IsIGVyciwgcmVmLCByZXM7XG4gICAgICAgICAgICAgIHJlZiA9IGFyZ3MsIFsuLi5hcmdzXSA9IHJlZiwgW2NiXSA9IHNwbGljZS5jYWxsKGFyZ3MsIC0xKTtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIGEgY2FsbGJhY2sgaWYgY2IgaXMgZGVmaW5lZCBhbmQgYSBmdW5jdGlvblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmVzID0gb2xkTWV0aG9kKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgY2IobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgICAgICAgIGVyciA9IGVycm9yMTtcbiAgICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRNZXRob2QoLi4uYXJncywgY2IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXRpc3RpY3MgY29udGFpbmVyXG4gICAgICAgIHRoaXMuc3RhdHMgPSB7XG4gICAgICAgICAgaGl0czogMCxcbiAgICAgICAgICBtaXNzZXM6IDAsXG4gICAgICAgICAga2V5czogMCxcbiAgICAgICAgICBrc2l6ZTogMCxcbiAgICAgICAgICB2c2l6ZTogMFxuICAgICAgICB9O1xuICAgICAgICAvLyBwcmUgYWxsb2NhdGUgdmFsaWQga2V5dHlwZXMgYXJyYXlcbiAgICAgICAgdGhpcy52YWxpZEtleVR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdO1xuICAgICAgICAvLyBpbml0YWxpemUgY2hlY2tpbmcgcGVyaW9kXG4gICAgICAgIHRoaXMuX2NoZWNrRGF0YSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGdldChrZXkpIHtcbiAgICAgICAgdmFyIF9yZXQsIGVycjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBrZXkgdHlwZXNcbiAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgZGF0YSBhbmQgaW5jcmVtZXQgc3RhdHNcbiAgICAgICAgaWYgKCh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSAmJiB0aGlzLl9jaGVjayhrZXksIHRoaXMuZGF0YVtrZXldKSkge1xuICAgICAgICAgIHRoaXMuc3RhdHMuaGl0cysrO1xuICAgICAgICAgIF9yZXQgPSB0aGlzLl91bndyYXAodGhpcy5kYXRhW2tleV0pO1xuICAgICAgICAgIC8vIHJldHVybiBkYXRhXG4gICAgICAgICAgcmV0dXJuIF9yZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbm90IGZvdW5kIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICB0aGlzLnN0YXRzLm1pc3NlcysrO1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWdldChrZXlzKSB7XG4gICAgICAgIHZhciBfZXJyLCBlcnIsIGksIGtleSwgbGVuLCBvUmV0O1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGNvbnZlcnQgYSBzdHJpbmcgdG8gYW4gYXJyYXkgb2Ygb25lIGtleVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICBfZXJyID0gdGhpcy5fZXJyb3IoXCJFS0VZU1RZUEVcIik7XG4gICAgICAgICAgdGhyb3cgX2VycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZpbmUgcmV0dXJuXG4gICAgICAgIG9SZXQgPSB7fTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBnZXQgZGF0YSBhbmQgaW5jcmVtZW50IHN0YXRzXG4gICAgICAgICAgaWYgKCh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSAmJiB0aGlzLl9jaGVjayhrZXksIHRoaXMuZGF0YVtrZXldKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0cy5oaXRzKys7XG4gICAgICAgICAgICBvUmV0W2tleV0gPSB0aGlzLl91bndyYXAodGhpcy5kYXRhW2tleV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBub3QgZm91bmQgcmV0dXJuIGEgZXJyb3JcbiAgICAgICAgICAgIHRoaXMuc3RhdHMubWlzc2VzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBhbGwgZm91bmQga2V5c1xuICAgICAgICByZXR1cm4gb1JldDtcbiAgICAgIH1cblxuICAgICAgc2V0KGtleSwgdmFsdWUsIHR0bCkge1xuICAgICAgICB2YXIgX2VyciwgZXJyLCBleGlzdGVudDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBjaGVjayBpZiBjYWNoZSBpcyBvdmVyZmxvd2luZ1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1heEtleXMgPiAtMSAmJiB0aGlzLnN0YXRzLmtleXMgPj0gdGhpcy5vcHRpb25zLm1heEtleXMpIHtcbiAgICAgICAgICBfZXJyID0gdGhpcy5fZXJyb3IoXCJFQ0FDSEVGVUxMXCIpO1xuICAgICAgICAgIHRocm93IF9lcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yY2UgdGhlIGRhdGEgdG8gc3RyaW5nXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VTdHJpbmcgJiYgIXR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBkZWZhdWx0IHR0bCBpZiBub3QgcGFzc2VkXG4gICAgICAgIGlmICh0dGwgPT0gbnVsbCkge1xuICAgICAgICAgIHR0bCA9IHRoaXMub3B0aW9ucy5zdGRUVEw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZXJuYWwgaGVscGVyIHZhcmlhYmxlc1xuICAgICAgICBleGlzdGVudCA9IGZhbHNlO1xuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmcgZGF0YSBmcm9tIHN0YXRzXG4gICAgICAgIGlmICh0aGlzLmRhdGFba2V5XSkge1xuICAgICAgICAgIGV4aXN0ZW50ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXRzLnZzaXplIC09IHRoaXMuX2dldFZhbExlbmd0aCh0aGlzLl91bndyYXAodGhpcy5kYXRhW2tleV0sIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IHRoaXMuX3dyYXAodmFsdWUsIHR0bCk7XG4gICAgICAgIHRoaXMuc3RhdHMudnNpemUgKz0gdGhpcy5fZ2V0VmFsTGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgLy8gb25seSBhZGQgdGhlIGtleXMgYW5kIGtleS1zaXplIGlmIHRoZSBrZXkgaXMgbmV3XG4gICAgICAgIGlmICghZXhpc3RlbnQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRzLmtzaXplICs9IHRoaXMuX2dldEtleUxlbmd0aChrZXkpO1xuICAgICAgICAgIHRoaXMuc3RhdHMua2V5cysrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInNldFwiLCBrZXksIHZhbHVlKTtcbiAgICAgICAgLy8gcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIG1zZXQoa2V5VmFsdWVTZXQpIHtcbiAgICAgICAgdmFyIF9lcnIsIGVyciwgaSwgaiwga2V5LCBrZXlWYWx1ZVBhaXIsIGxlbiwgbGVuMSwgdHRsLCB2YWw7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgY2FjaGUgaXMgb3ZlcmZsb3dpbmdcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhLZXlzID4gLTEgJiYgdGhpcy5zdGF0cy5rZXlzICsga2V5VmFsdWVTZXQubGVuZ3RoID49IHRoaXMub3B0aW9ucy5tYXhLZXlzKSB7XG4gICAgICAgICAgX2VyciA9IHRoaXMuX2Vycm9yKFwiRUNBQ0hFRlVMTFwiKTtcbiAgICAgICAgICB0aHJvdyBfZXJyO1xuICAgICAgICB9XG5cbi8vIGxvb3Agb3ZlciBrZXlWYWx1ZVNldCB0byB2YWxpZGF0ZSBrZXkgYW5kIHR0bFxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlWYWx1ZVNldC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGtleVZhbHVlUGFpciA9IGtleVZhbHVlU2V0W2ldO1xuICAgICAgICAgICh7a2V5LCB2YWwsIHR0bH0gPSBrZXlWYWx1ZVBhaXIpO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIHR0bCBhbmQgaXQncyBhIG51bWJlclxuICAgICAgICAgIGlmICh0dGwgJiYgdHlwZW9mIHR0bCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgX2VyciA9IHRoaXMuX2Vycm9yKFwiRVRUTFRZUEVcIik7XG4gICAgICAgICAgICB0aHJvdyBfZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBrZXkgdHlwZXNcbiAgICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSBrZXlWYWx1ZVNldC5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICBrZXlWYWx1ZVBhaXIgPSBrZXlWYWx1ZVNldFtqXTtcbiAgICAgICAgICAoe2tleSwgdmFsLCB0dGx9ID0ga2V5VmFsdWVQYWlyKTtcbiAgICAgICAgICB0aGlzLnNldChrZXksIHZhbCwgdHRsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZGVsKGtleXMpIHtcbiAgICAgICAgdmFyIGRlbENvdW50LCBlcnIsIGksIGtleSwgbGVuLCBvbGRWYWw7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gY29udmVydCBrZXlzIHRvIGFuIGFycmF5IG9mIGl0c2VsZlxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICBrZXlzID0gW2tleXNdO1xuICAgICAgICB9XG4gICAgICAgIGRlbENvdW50ID0gMDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSBpZiBleGlzdGVudFxuICAgICAgICAgIGlmICh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjYWxjIHRoZSBzdGF0c1xuICAgICAgICAgICAgdGhpcy5zdGF0cy52c2l6ZSAtPSB0aGlzLl9nZXRWYWxMZW5ndGgodGhpcy5fdW53cmFwKHRoaXMuZGF0YVtrZXldLCBmYWxzZSkpO1xuICAgICAgICAgICAgdGhpcy5zdGF0cy5rc2l6ZSAtPSB0aGlzLl9nZXRLZXlMZW5ndGgoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMua2V5cy0tO1xuICAgICAgICAgICAgZGVsQ291bnQrKztcbiAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgdmFsdWVcbiAgICAgICAgICAgIG9sZFZhbCA9IHRoaXMuZGF0YVtrZXldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtrZXldO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRydWVcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlbFwiLCBrZXksIG9sZFZhbC52KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbENvdW50O1xuICAgICAgfVxuXG4gICAgICB0YWtlKGtleSkge1xuICAgICAgICB2YXIgX3JldDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBfcmV0ID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKChfcmV0ICE9IG51bGwpKSB7XG4gICAgICAgICAgdGhpcy5kZWwoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JldDtcbiAgICAgIH1cblxuICAgICAgdHRsKGtleSwgdHRsKSB7XG4gICAgICAgIHZhciBlcnI7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgdHRsIHx8ICh0dGwgPSB0aGlzLm9wdGlvbnMuc3RkVFRMKTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIGV4aXN0ZW50IGRhdGEgYW5kIHVwZGF0ZSB0aGUgdHRsIHZhbHVlXG4gICAgICAgIGlmICgodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkgJiYgdGhpcy5fY2hlY2soa2V5LCB0aGlzLmRhdGFba2V5XSkpIHtcbiAgICAgICAgICAvLyBpZiB0dGwgPCAwIGRlbGV0ZSB0aGUga2V5LiBvdGhlcndpc2UgcmVzZXQgdGhlIHZhbHVlXG4gICAgICAgICAgaWYgKHR0bCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFba2V5XSA9IHRoaXMuX3dyYXAodGhpcy5kYXRhW2tleV0udiwgdHRsLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJldHVybiBmYWxzZSBpZiBrZXkgaGFzIG5vdCBiZWVuIGZvdW5kXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdldFR0bChrZXkpIHtcbiAgICAgICAgdmFyIF90dGwsIGVycjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIGV4aXN0YW50IGRhdGEgYW5kIHVwZGF0ZSB0aGUgdHRsIHZhbHVlXG4gICAgICAgIGlmICgodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkgJiYgdGhpcy5fY2hlY2soa2V5LCB0aGlzLmRhdGFba2V5XSkpIHtcbiAgICAgICAgICBfdHRsID0gdGhpcy5kYXRhW2tleV0udDtcbiAgICAgICAgICByZXR1cm4gX3R0bDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZXR1cm4gdW5kZWZpbmVkIGlmIGtleSBoYXMgbm90IGJlZW4gZm91bmRcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGtleXMoKSB7XG4gICAgICAgIHZhciBfa2V5cztcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBfa2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YSk7XG4gICAgICAgIHJldHVybiBfa2V5cztcbiAgICAgIH1cblxuICAgICAgaGFzKGtleSkge1xuICAgICAgICB2YXIgX2V4aXN0cztcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBfZXhpc3RzID0gKHRoaXMuZGF0YVtrZXldICE9IG51bGwpICYmIHRoaXMuX2NoZWNrKGtleSwgdGhpcy5kYXRhW2tleV0pO1xuICAgICAgICByZXR1cm4gX2V4aXN0cztcbiAgICAgIH1cblxuICAgICAgZ2V0U3RhdHMoKSB7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHM7XG4gICAgICB9XG5cbiAgICAgIGZsdXNoQWxsKF9zdGFydFBlcmlvZCA9IHRydWUpIHtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBwYXJhbWV0ZXIganVzdCBmb3IgdGVzdGluZ1xuXG4gICAgICAgIC8vIHNldCBkYXRhIGVtcHR5XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICAvLyByZXNldCBzdGF0c1xuICAgICAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgICAgIGhpdHM6IDAsXG4gICAgICAgICAgbWlzc2VzOiAwLFxuICAgICAgICAgIGtleXM6IDAsXG4gICAgICAgICAga3NpemU6IDAsXG4gICAgICAgICAgdnNpemU6IDBcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVzZXQgY2hlY2sgcGVyaW9kXG4gICAgICAgIHRoaXMuX2tpbGxDaGVja1BlcmlvZCgpO1xuICAgICAgICB0aGlzLl9jaGVja0RhdGEoX3N0YXJ0UGVyaW9kKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmx1c2hcIik7XG4gICAgICB9XG5cbiAgICAgIGZsdXNoU3RhdHMoKSB7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gcmVzZXQgc3RhdHNcbiAgICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgICBoaXRzOiAwLFxuICAgICAgICAgIG1pc3NlczogMCxcbiAgICAgICAgICBrZXlzOiAwLFxuICAgICAgICAgIGtzaXplOiAwLFxuICAgICAgICAgIHZzaXplOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdChcImZsdXNoX3N0YXRzXCIpO1xuICAgICAgfVxuXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICB0aGlzLl9raWxsQ2hlY2tQZXJpb2QoKTtcbiAgICAgIH1cblxuICAgICAgX2NoZWNrRGF0YShzdGFydFBlcmlvZCA9IHRydWUpIHtcbiAgICAgICAgdmFyIGtleSwgcmVmLCB2YWx1ZTtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICByZWYgPSB0aGlzLmRhdGE7XG4gICAgICAgIC8vIHJ1biB0aGUgaG91c2VrZWVwaW5nIG1ldGhvZFxuICAgICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgICB2YWx1ZSA9IHJlZltrZXldO1xuICAgICAgICAgIHRoaXMuX2NoZWNrKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFBlcmlvZCAmJiB0aGlzLm9wdGlvbnMuY2hlY2twZXJpb2QgPiAwKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1RpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX2NoZWNrRGF0YSwgdGhpcy5vcHRpb25zLmNoZWNrcGVyaW9kICogMTAwMCwgc3RhcnRQZXJpb2QpO1xuICAgICAgICAgIGlmICgodGhpcy5jaGVja1RpbWVvdXQgIT0gbnVsbCkgJiYgKHRoaXMuY2hlY2tUaW1lb3V0LnVucmVmICE9IG51bGwpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrVGltZW91dC51bnJlZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAjIyBfa2lsbENoZWNrUGVyaW9kXG5cbiAgICAgIC8vIHN0b3AgdGhlIGNoZWNrZGF0YSBwZXJpb2QuIE9ubHkgbmVlZGVkIHRvIGFib3J0IHRoZSBzY3JpcHQgaW4gdGVzdGluZyBtb2RlLlxuICAgICAgX2tpbGxDaGVja1BlcmlvZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRoaXMuY2hlY2tUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfY2hlY2soa2V5LCBkYXRhKSB7XG4gICAgICAgIHZhciBfcmV0dmFsO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIF9yZXR2YWwgPSB0cnVlO1xuICAgICAgICAvLyBkYXRhIGlzIGludmFsaWQgaWYgdGhlIHR0bCBpcyB0b28gb2xkIGFuZCBpcyBub3QgMFxuICAgICAgICAvLyBjb25zb2xlLmxvZyBkYXRhLnQgPCBEYXRlLm5vdygpLCBkYXRhLnQsIERhdGUubm93KClcbiAgICAgICAgaWYgKGRhdGEudCAhPT0gMCAmJiBkYXRhLnQgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWxldGVPbkV4cGlyZSkge1xuICAgICAgICAgICAgX3JldHZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZWwoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KFwiZXhwaXJlZFwiLCBrZXksIHRoaXMuX3Vud3JhcChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXR2YWw7XG4gICAgICB9XG5cbiAgICAgIF9pc0ludmFsaWRLZXkoa2V5KSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgaWYgKHJlZiA9IHR5cGVvZiBrZXksIGluZGV4T2YuY2FsbCh0aGlzLnZhbGlkS2V5VHlwZXMsIHJlZikgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKFwiRUtFWVRZUEVcIiwge1xuICAgICAgICAgICAgdHlwZTogdHlwZW9mIGtleVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF93cmFwKHZhbHVlLCB0dGwsIGFzQ2xvbmUgPSB0cnVlKSB7XG4gICAgICAgIHZhciBsaXZldGltZSwgbm93LCBvUmV0dXJuLCB0dGxNdWx0aXBsaWNhdG9yO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnVzZUNsb25lcykge1xuICAgICAgICAgIGFzQ2xvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZpbmUgdGhlIHRpbWUgdG8gbGl2ZVxuICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBsaXZldGltZSA9IDA7XG4gICAgICAgIHR0bE11bHRpcGxpY2F0b3IgPSAxMDAwO1xuICAgICAgICAvLyB1c2UgZ2l2ZW4gdHRsXG4gICAgICAgIGlmICh0dGwgPT09IDApIHtcbiAgICAgICAgICBsaXZldGltZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodHRsKSB7XG4gICAgICAgICAgbGl2ZXRpbWUgPSBub3cgKyAodHRsICogdHRsTXVsdGlwbGljYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIHN0YW5kYXJkIHR0bFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RkVFRMID09PSAwKSB7XG4gICAgICAgICAgICBsaXZldGltZSA9IHRoaXMub3B0aW9ucy5zdGRUVEw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpdmV0aW1lID0gbm93ICsgKHRoaXMub3B0aW9ucy5zdGRUVEwgKiB0dGxNdWx0aXBsaWNhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIHRoZSB3cmFwcGVkIHZhbHVlXG4gICAgICAgIHJldHVybiBvUmV0dXJuID0ge1xuICAgICAgICAgIHQ6IGxpdmV0aW1lLFxuICAgICAgICAgIHY6IGFzQ2xvbmUgPyBjbG9uZSh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAjIyBfdW53cmFwXG5cbiAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBleHRyYWN0IGdldCB0aGUgdmFsdWUgb3V0IG9mIHRoZSB3cmFwcGVkIHZhbHVlXG4gICAgICBfdW53cmFwKHZhbHVlLCBhc0Nsb25lID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VDbG9uZXMpIHtcbiAgICAgICAgICBhc0Nsb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnYgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhc0Nsb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmUodmFsdWUudik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gIyMgX2dldEtleUxlbmd0aFxuXG4gICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdGhlIGNhbGN1bGF0ZSB0aGUga2V5IGxlbmd0aFxuICAgICAgX2dldEtleUxlbmd0aChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleS50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgX2dldFZhbExlbmd0aCh2YWx1ZSkge1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgYSBTdHJpbmcgZ2V0IHRoZSByZWFsIGxlbmd0aFxuICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmNlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gZm9yY2Ugc3RyaW5nIGlmIGl0J3MgZGVmaW5lZCBhbmQgbm90IHBhc3NlZFxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgYW4gQXJyYXkgbXVsdGlwbHkgZWFjaCBlbGVtZW50IHdpdGggYSBkZWZpbmVkIGRlZmF1bHQgbGVuZ3RoXG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hcnJheVZhbHVlU2l6ZSAqIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKHZhbHVlICE9IG51bGwgPyB2YWx1ZS50aGVuIDogdm9pZCAwKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgYSBQcm9taXNlLCB1c2UgZGVmaW5lZCBkZWZhdWx0XG4gICAgICAgICAgLy8gKGNhbid0IGNhbGN1bGF0ZSBhY3R1YWwvcmVzb2x2ZWQgdmFsdWUgc2l6ZSBzeW5jaHJvbm91c2x5KVxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucHJvbWlzZVZhbHVlU2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIEJ1ZmZlciAhPT0gbnVsbCA/IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgOiB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKCh2YWx1ZSAhPSBudWxsKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgZGF0YSBpcyBhbiBPYmplY3QgbXVsdGlwbHkgZWFjaCBlbGVtZW50IHdpdGggYSBkZWZpbmVkIGRlZmF1bHQgbGVuZ3RoXG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vYmplY3RWYWx1ZVNpemUgKiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0IGZhbGxiYWNrXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2Vycm9yKHR5cGUsIGRhdGEgPSB7fSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIGVycm9yIG9iamVjdFxuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBlcnJvci5uYW1lID0gdHlwZTtcbiAgICAgICAgZXJyb3IuZXJyb3Jjb2RlID0gdHlwZTtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IHRoaXMuRVJST1JTW3R5cGVdICE9IG51bGwgPyB0aGlzLkVSUk9SU1t0eXBlXShkYXRhKSA6IFwiLVwiO1xuICAgICAgICBlcnJvci5kYXRhID0gZGF0YTtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlcnJvciBvYmplY3RcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuXG4gICAgICBfaW5pdEVycm9ycygpIHtcbiAgICAgICAgdmFyIF9lcnJNc2csIF9lcnJULCByZWY7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgdGhpcy5FUlJPUlMgPSB7fTtcbiAgICAgICAgcmVmID0gdGhpcy5fRVJST1JTO1xuICAgICAgICBmb3IgKF9lcnJUIGluIHJlZikge1xuICAgICAgICAgIF9lcnJNc2cgPSByZWZbX2VyclRdO1xuICAgICAgICAgIHRoaXMuRVJST1JTW19lcnJUXSA9IHRoaXMuY3JlYXRlRXJyb3JNZXNzYWdlKF9lcnJNc2cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUVycm9yTWVzc2FnZShlcnJNc2cpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gZXJyTXNnLnJlcGxhY2UoXCJfX2tleVwiLCBhcmdzLnR5cGUpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIE5vZGVDYWNoZS5wcm90b3R5cGUuX0VSUk9SUyA9IHtcbiAgICAgIFwiRU5PVEZPVU5EXCI6IFwiS2V5IGBfX2tleWAgbm90IGZvdW5kXCIsXG4gICAgICBcIkVDQUNIRUZVTExcIjogXCJDYWNoZSBtYXgga2V5cyBhbW91bnQgZXhjZWVkZWRcIixcbiAgICAgIFwiRUtFWVRZUEVcIjogXCJUaGUga2V5IGFyZ3VtZW50IGhhcyB0byBiZSBvZiB0eXBlIGBzdHJpbmdgIG9yIGBudW1iZXJgLiBGb3VuZDogYF9fa2V5YFwiLFxuICAgICAgXCJFS0VZU1RZUEVcIjogXCJUaGUga2V5cyBhcmd1bWVudCBoYXMgdG8gYmUgYW4gYXJyYXkuXCIsXG4gICAgICBcIkVUVExUWVBFXCI6IFwiVGhlIHR0bCBhcmd1bWVudCBoYXMgdG8gYmUgYSBudW1iZXIuXCJcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5vZGVDYWNoZTtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-cache/lib/node_cache.js\n");

/***/ })

};
;